[["index.html", "Visualization in R workshop Chapter 1 About", " Visualization in R workshop Anna Heintz-Buschart and Joachim Goedhart 2022-09-14 Chapter 1 About This book is based on a collection of R markdown files used during a workshop of the Science Park Study Group at University of Amsterdam, 14th September 2022. "],["hello-world---base-r.html", "Chapter 2 Hello World - base R 2.1 Welcome 2.2 Test ‘knitting’ 2.3 Resources on R", " Chapter 2 Hello World - base R 2.1 Welcome Welcome to the R visualization workshop. If you are completely new to R and need to find something in the RStudio environment, check out this cheat sheet. This is an R Markdown Notebook. You can toggle its appearance by clicking Source or Visual at the top of the script tab (or by clicking on the gear symbol and (de-)selecting ‘Use Visual Editor’). The aim of this notebook is to familiarize yourself with this format. It will also check whether the functions you need for today are working. 2.1.1 Interacting with R Within a workbook, you can interact with R in two ways: the traditional way: typing commands or code into the Console that you usually find in the bottom left window in RStudio. The &gt; at the beginning of a line is called a ‘prompt.’ You can only type commands, when you see the prompt. If you gave a command, and there is no prompt, it means R is still calculating. Results from entering commands in the console appear in the console (except for e.g. plots, which appear in their own window). You can also interact with R via the R Markdown Notebook: The notebook consists of two types of text, markdown as this text, and code ‘chunks.’ These chunks can be executed (see the little symbols at the top of the chunks below). When you execute code within the notebook, the results appear beneath the code. Try executing the chunk below by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. ## [1] &quot;Hello World.&quot; 2.1.2 Chunks You can add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. You could do this for example to see what happens if you change some code without loosing the original. For example, try to copy some code from above into a new chunk below and move the eyes or change the mouth. Note: You can’t have the same name for two chunks in the same file, so you need to change the name when copying, i.e. the word behind r. 2.2 Test ‘knitting’ A cool feature of notebooks is that you can produce an HTML file from them that contains the text, code, and outputs. You can use this as your data report. To produce an HTML file containing the code and output, you can click the Knit button or press Cmd+Shift+K. Here‘s a quick summary of R markdown. Refer to the R markdown guidelines to learn more on how to control the chunks’ appearance in the final output. You will see examples in the following notebooks, too. Knit this markdown to test that everything is working fine for you. Note: If you get the error message Duplicate chunk label… , you forgot to change the chunk labels/names. if(!require(RColorBrewer)){ install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(RColorBrewer) } ## Loading required package: RColorBrewer if(!require(openxlsx)){ install.packages(&quot;openxlsx&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(openxlsx) } ## Loading required package: openxlsx Here should be a list of files we provided you: ## [1] &quot;allData.xlsx&quot; &quot;ERAWIJANTARI_metab.tsv&quot; ## [3] &quot;ERAWIJANTARI_metaD.tsv&quot; &quot;hairEyeColor.tsv&quot; ## [5] &quot;hairEyeColor.xlsx&quot; &quot;plantGrowth.tsv&quot; ## [7] &quot;plantGrowth.xlsx&quot; &quot;USArrests_comma.csv&quot; ## [9] &quot;USArrests_comma.xlsx&quot; &quot;USArrests_commaNoHeader.csv&quot; ## [11] &quot;USArrests_semicolon.csv&quot; &quot;USArrests_tab.txt&quot; ## [13] &quot;USArrests_tabComments.txt&quot; &quot;USArrests_tabManipulated.txt&quot; ## [15] &quot;USArrests.tsv&quot; &quot;USArrestsComma_tab.txt&quot; Ask the instructor, if something does not work. 2.3 Resources on R Modern Statistics for Modern Biology (Susan Holmes &amp; Wolfgang Huber): https://web.stanford.edu/class/bios221/book/index.html Introduction to Data Science (Rafael A. Irizarry): https://leanpub.com/datasciencebook R for Data Science (Hadley Wickham &amp; Garrett Grolemund): https://r4ds.had.co.nz/index.html R Programming for Data Science (Roger D. Peng): https://leanpub.com/rprogramming R Cookbook (James (JD) Long &amp; Paul Teetor): https://rc2e.com/ Advanced R (Hadley Wickham): https://adv-r.hadley.nz/ "],["importing-data---base-r.html", "Chapter 3 Importing data - base R 3.1 Using base R 3.2 Further methods", " Chapter 3 Importing data - base R In this chapter, we take a look at functions to import data into R. 3.1 Using base R If we are only relying on base R, we need our data in common text formats, such as tab- or comma separated files. It’s not unusual for laboratory machines, analysis programs, or bioinformaticians to supply the data in such a format. If you’ve got data in Microsoft Excel, you can choose comma-separated (.csv) and tab-separated (.tsv) format from the Save as... menu. R’s base functions for reading files need to be told about the structure of the file. Then, it is actually pretty flexible with the input format. Here are some examples. Take a look at the files we import in a text editor, such as Textedit or Notepad, to see what the original data looks like. 3.1.1 Tab-delimited data with a header and using standard decimal points The first example is a pretty standard text file without any hidden problems. Remember, you can execute the chunks by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. UA_v1 &lt;- read.delim(&quot;../datasets/USArrests_tab.txt&quot;) head(UA_v1) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.9 204 78 38.7 3.1.2 Non-standard decimal points If your computer is set up with Dutch standards, Excel most likely exports numbers with a comma instead of a point/full stop as decimal point. Here’s how you can tell R about this. UA_v2 &lt;- read.delim(&quot;../datasets/USArrestsComma_tab.txt&quot;,dec=&quot;,&quot;) head(UA_v2) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.9 204 78 38.7 3.1.3 Comma-separated data with a header and using standard decimal points Data with standard decimal points might also come separated by commas: UA_v3 &lt;- read.csv(&quot;../datasets/USArrests_comma.csv&quot;) head(UA_v3) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.9 204 78 38.7 If you look at the chunk above, we used different functions to read the tab- and comma-separated files. This saves us some typing, because by default read.delim separates the input at a tab and read.csv separates the input at the comma. However, read.delim and read.csv (along with a whole bunch of other functions) belong to one family. They only differ in their defaults, so if you explicitly state the field separator and some other formatting characteristics (like the decimal point dec above), you can interchange these functions. I find it a lot easier to remember the names of those arguments than the defaults of all the functions. So, I will use read.delim for the rest of the notebook: UA_v3b &lt;- read.delim(&quot;../datasets/USArrests_comma.csv&quot;,sep=&quot;,&quot;) head(UA_v3b) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.9 204 78 38.7 3.1.4 Tables without headers While not best practice, you sometimes get data without a set of column headers: UA_v4 &lt;- read.delim(&quot;../datasets/USArrests_commaNoHeader.csv&quot;,sep=&quot;,&quot;) head(UA_v4) ## X13.2 X236 X58 X21.2 ## 1 10.0 263 48 44.5 ## 2 8.1 294 80 31.0 ## 3 8.8 190 50 19.5 ## 4 9.0 276 91 40.6 ## 5 7.9 204 78 38.7 ## 6 3.3 110 77 11.1 You can add column names manually: colnames(UA_v4) &lt;- c(&quot;Murder&quot;, &quot;Assault&quot;, &quot;UrbanPop&quot;, &quot;Rape&quot;) head(UA_v4) ## Murder Assault UrbanPop Rape ## 1 10.0 263 48 44.5 ## 2 8.1 294 80 31.0 ## 3 8.8 190 50 19.5 ## 4 9.0 276 91 40.6 ## 5 7.9 204 78 38.7 ## 6 3.3 110 77 11.1 3.1.5 Additional lines Sometimes your data has some kind of preface that does not match the rest of your data. You can ignore it, if it is labeled with a specific character like so: UA_v5 &lt;- read.delim(&quot;../datasets/USArrests_tabComments.txt&quot;,comment.char = &quot;#&quot;) head(UA_v5) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.9 204 78 38.7 Such a character is also ignored further down: UA_v6 &lt;- read.delim(&quot;../datasets/USArrests_tabManipulated.txt&quot;,comment.char = &quot;;&quot;) head(UA_v6) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 8.8 190 50 19.5 ## 5 9.0 276 91 40.6 ## 6 7.2 113 65 21.0 There are many more options, e.g.: skip : if you want to skip a certain number of lines at the top quote : if fields with text are enclosed by quotation marks other than \" or ' row.names : if one of the columns contains row names, which can be handled differently in R na.strings : if you need to mark non-available data points, e.g. “NaN” or “n.d.”; you can also use multiple words, e.g. c(“NA,”“n.d.”“Na”) stringsAsFactors : if R should interpret columns with words in the data table as factors instead of a vector of words. Don’t worry, if you don’t know the difference between factors and character vectors at this moment. But if you’re curious, take a look at the chapter on factors in the advanced R book. 3.2 Further methods 3.2.1 Excel files There are several functions/packages that can deal with the .xlsx format, e.g. readxl, which is automatically installed with the tidyverse package or openxlsx, which is demonstrated below. if(!require(openxlsx)){ install.packages(&quot;openxlsx&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(openxlsx) } pg &lt;- read.xlsx(&quot;../datasets/plantGrowth.xlsx&quot;) head(pg) ## weight group ## 1 4.17 ctrl ## 2 5.58 ctrl ## 3 5.18 ctrl ## 4 6.11 ctrl ## 5 4.50 ctrl ## 6 4.61 ctrl You can see above that this function is smart enough to take the decimal separator from Excel and change it to the standard full stop. By default, the first line becomes the column names. It is even a bit more smart: Take a look at the second sheet of allData.xlsx in the course material. It does not feature the cleanest formatting with those empty lines. But read.xlsx understands that we don’t want to have empty lines. To load the second sheet, we need to use the sheet argument - this determines which of the sheets in an .xlsx file to read. You can either give the name sheet=hairEyeColor or the number of the sheet: hc &lt;- read.xlsx(&quot;../datasets/allData.xlsx&quot;,sheet = 2) head(hc) ## Hair Eye Sex Freq ## 1 Black Brown Male 32 ## 2 Brown Brown Male 53 ## 3 Red Brown Male 10 ## 4 Blond Brown Male 3 ## 5 Black Blue Male 11 ## 6 Brown Blue Male 50 3.2.2 Reading from URLs You can use base R’s read.delim/read.csv/read.table family of functions to load data from a webpage by giving the URL: turl &lt;- read.delim(&quot;https://github.com/a-h-b/R_base_vis_course/raw/main/TestCSV.csv&quot;, sep = &quot;,&quot;) head(turl) ## Header.1 Header.2 ## 1 Text 1 ## 2 and 2 ## 3 more 3 ## 4 text 4 3.2.3 Reading from the clipboard R can actually read data that you’ve copied ‘from the clipboard.’ But we recommend to never use this function, because it’s not reproducible. "],["intro-to-the-tidyverse.html", "Chapter 4 Intro to the {tidyverse} 4.1 Why {tidyverse}? 4.2 Reading data from excel 4.3 The pipe operator 4.4 Resources on tidyverse", " Chapter 4 Intro to the {tidyverse} 4.1 Why {tidyverse}? The {tidyverse} is a collection of R packages that extend the functionality of base R. The packages are developed to simplify and accelerate data analysis with R. All packages share an underlying design philosophy, grammar, and data structures. You may say that the {tidyverse} equips R with superpowers. Some of the packages may be familiar, e.g. {ggplot2} or {tidyr} and these may be installed already. But if you’d like to use some of these, you may as well install it in one go: if(!require(tidyverse)){ install.packages(&quot;tidyverse&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(tidyverse) } ## Loading required package: tidyverse ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 ## ✓ tibble 3.1.6 ✓ dplyr 1.0.8 ## ✓ tidyr 1.2.0 ✓ stringr 1.4.0 ## ✓ readr 2.1.2 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 4.2 Reading data from excel The {readxl} package that is installed as part of the {tidyverse} can be used to read data from excel files: library(readxl) df_xl &lt;- read_excel(&quot;../datasets/allData.xlsx&quot;, sheet = 2) ## New names: ## * `` -&gt; ...4 head(df_xl) ## # A tibble: 6 × 5 ## Hair Eye Sex ...4 Freq ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA ## 2 Black Brown Male NA 32 ## 3 Brown Brown Male NA 53 ## 4 Red Brown Male NA 10 ## 5 Blond Brown Male NA 3 ## 6 Black Blue Male NA 11 4.3 The pipe operator Unlike the {openxlsx} package, there is no automatic detection and removal of empty lines or columns. To do this we can add a function to do this with the pipe operator %&gt;% that is often used in the tidyverse. This operator is used to take the result of a function and feed it into the next function. The function that we will use is drop_na() and we tell this function to remove any line with “NA” in the column “Hair” from the data: df_xl &lt;- read_excel(&quot;../datasets/allData.xlsx&quot;, sheet = 2, skip = 1) %&gt;% drop_na(Hair) ## New names: ## * `` -&gt; ...4 head(df_xl) ## # A tibble: 6 × 5 ## Hair Eye Sex ...4 Freq ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 Black Brown Male NA 32 ## 2 Brown Brown Male NA 53 ## 3 Red Brown Male NA 10 ## 4 Blond Brown Male NA 3 ## 5 Black Blue Male NA 11 ## 6 Brown Blue Male NA 50 It is possible to use multiple pipe operators to combine multiple functions in a single command. Here we add another function select() to get rid of the 4th column, since it is empty. The - indicates that we do not select column number 4. Since the commands become pretty long when multiple pipe operators are used, it is good practice to start each function on a new line: read_excel(&quot;../datasets/allData.xlsx&quot;, sheet = 2, skip = 1) %&gt;% drop_na(Hair) %&gt;% select(-4) %&gt;% head() ## New names: ## * `` -&gt; ...4 ## # A tibble: 6 × 4 ## Hair Eye Sex Freq ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Black Brown Male 32 ## 2 Brown Brown Male 53 ## 3 Red Brown Male 10 ## 4 Blond Brown Male 3 ## 5 Black Blue Male 11 ## 6 Brown Blue Male 50 There are many more functions for data manipulation in the tidyverse, but in this workshop we will focus on the use of the {ggplot2} package for plotting. 4.4 Resources on tidyverse Tidyverse website: https://www.tidyverse.org R for Data Science (Hadley Wickham &amp; Garrett Grolemund): https://r4ds.had.co.nz/index.html A Modern Dive into R and the Tidyverse (Chester Ismay &amp; Albert Y. Kim ): https://moderndive.com "],["introduction-to-scatter-plots-in-base-r.html", "Chapter 5 Introduction to scatter plots in base R 5.1 Set up 5.2 Formatting plots 5.3 Axes 5.4 Points 5.5 Legends 5.6 Lines", " Chapter 5 Introduction to scatter plots in base R 5.1 Set up In this chapter, we take a look at the plotting parameters in base R plotting. We’ll just grab some colours from a different package. if(!require(RColorBrewer)){ install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(RColorBrewer) } We’ll use the iris data set that comes with R. data(&quot;iris&quot;) #import like this is possible for R&#39;s inbuilt datasets head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa summary(iris) #dataset is present in the workspace with the dataset name ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## You see that you have 5 columns, with measurements of iris flowers in three species. 5.2 Formatting plots 5.2.1 Defaults We’ll use the length and widths of the petals. Let’s plot them: plot(iris$Petal.Length, #x coordinates iris$Petal.Width, #y coordinates xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;) This is not very pretty, but it was super easy. Let’s look at R’s options to improve the optics: 5.2.2 Margins Margins are defined for a whole plot using par (parameters). The default often leaves a lot of white space, so you may want to decrease it. Remember, you can change the code in the chunk below to try different options, e.g. for the mar argument. par(mar=c(4,4,0.5,0.5)) #mar for margin, 1 is bottom, 2 is left, 3 is top, 4 is right plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;) 5.2.3 Plot borders You can remove the borders around your plot. par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;) #no box You can have a part of the box: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;l&quot;) # L-shaped box (bottom and left) l is for bottom and left, o is for everywhere, c is for all sides except the right… guess who u would be. You can also add the box after the plot: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;) # no box here box(&quot;plot&quot;,bty=&quot;l&quot;) #box is plotted here This way, you’re a bit more flexible with the look: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;) box(&quot;plot&quot;,bty=&quot;l&quot;, col=&quot;red&quot;, #red line lwd=3) #thick line You can also add a box around the image: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;) box(&quot;plot&quot;,bty=&quot;l&quot;, col=&quot;red&quot;, lwd=3) box(&quot;figure&quot;,bty=&quot;o&quot;, #box around the figure col=&quot;blue&quot;, lwd=5) #extra fat so we can see it 5.3 Axes Axes are super important. R gives you all the control over them. For instance, you can plot them or not: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;, # no box, so we see the axes axes=F) #no axes This is useful for plots where the axes are uninformative (e.g. NMDS, t-SNE, uMap plots). You can also plot just one axis: par(mar=c(4,4,0.5,0.5)) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;n&quot;, # no box, so we see the axes xaxt=&quot;n&quot;) #no x-axis (yaxt = &quot;n&quot; would suppress the y axis) 5.3.1 Axis marks What is marked on an axis and how it is displayed is also in your hands. You can adjust the overall look: par(mar=c(3.2,3.2,0.5,0.5), mgp=c(2,0.5,0), #distance of axis label, axis values, and axis position to plot tcl=-0.3) #tick length (- indicates that it goes into the margin) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;l&quot;) Play around with these parameters. par(mar=c(2,2,0.5,0.5), mgp=c(1,0,0), #distance of axis label, axis values, and axis position to plot tcl=0.4) #tick length goes into the plot plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;o&quot;) You can change the orientation of the markings: par(mar=c(3.2,3.2,0.5,0.5), mgp=c(2,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;l&quot;, las = 1) # all letters horizontal (2 would be orthogonal to the axes) And their size: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;l&quot;, las = 1, cex.axis = 0.8) #size (1 is normal) And their font: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, bty = &quot;l&quot;, las = 1, cex.axis = 0.8, font = 3) # 1 is normal, 2 is fat If you want to have more control, create the axes after the plot. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.2,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, axes = F) #no axis axis(1, #x axis cex.axis = 0.8, font = 3, col.ticks =&quot;blue&quot;, col.axis = &quot;blue&quot;) axis(2, #y axis cex.axis = 0.8, las = 1, font = 2, col.ticks =&quot;red&quot;, col.axis = &quot;red&quot;, mgp = c(1.7,0.5,0)) box(&quot;plot&quot;,bty=&quot;l&quot;) Creating the axes after the plot allows allows you to change what is displayed. Let’s say we measured the petals in cm but now we want to display their length in mm. You can do that while plotting, as shown here: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length [mm]&quot;, ylab = &quot;petal width [cm]&quot;, xaxt = &quot;n&quot;, #no x-axis bty=&quot;l&quot;, las=1) axis(1, #x axis at = 1:7, #same values as before labels = 1:7 * 10) # values times 10 However, this is slightly dangerous, because you need to manually make sure that the values that are shown really belong to the axis. For example, this could happen: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, xaxt = &quot;n&quot;, #no x-axis las=1, bty=&quot;l&quot;) axis(1, #x axis at = 1:7, #same values as before labels = -7:-1) # bullshit values We therefore recommend that you do any transformations on you data before you start plotting. 5.3.2 Axis labels The axis names are controllable, too: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, las=1, font.lab = 2, bty=&quot;l&quot;) If you want to control them separately, use mtext: par(mar=c(2.4,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, ann = F, #no axis labels/annotions las=1, bty=&quot;l&quot;) mtext(&quot;petal length&quot;, #text 1, #side (bottom) 1.2, #distance from plot font = 2, #font col = &quot;darkgreen&quot;, #colour adj = 1) #position along the axis (0-1) mtext(&quot;petal width&quot;, #text 2, #side (left) 1.9, #distance from plot font = 1, #font col = &quot;blue&quot;, #colour adj = 0.8) #position along the axis (0-1) With mtext you can also add multiple axis labels: par(mar=c(3.4,3.4,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, ann = F, #no axis labels/annotions las=1, bty=&quot;l&quot;) mtext(&quot;petal length&quot;, #text 1, #side (bottom) 2.2, #distance from plot font = 2) #font mtext(&quot;short&quot;, #text 1, #side (bottom) 1.2, #distance from plot adj = 0.1) #position mtext(&quot;long&quot;, #text 1, #side (bottom) 1.2, #distance from plot adj = 0.9) #position mtext(&quot;petal width&quot;, #text 2, #side (left) 2, #distance from plot font = 2) #font You can have weird symbols in your axis labels: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = expression(paste(&quot;petal length [&quot;, 10^4, &quot; &quot;, mu ,&quot;m]&quot;)), ylab = expression(paste(&quot;petal width [&quot;, 10^4, &quot; &quot;, mu ,&quot;m]&quot;)), las=1, bty=&quot;l&quot;) 5.3.3 Scales and ranges You can choose scales and ranges. E.g. logarithmic scales: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, log = &quot;xy&quot;, #both axes logarithmic, you can chose x or y to have only one transformed las=1, bty=&quot;l&quot;) You can also change where the x and y-axis start and stop. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, log = &quot;xy&quot;, xlim = c(0.1,10), #lower and upper end for x axis ylim = c(0.1,10), #lower and upper end for y axis las=1, bty=&quot;l&quot;) But you need to take care yourself that everything you wanted to plot is visible, because R does not complain: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.4,0), tcl=-0.3, cex.axis = 0.8) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, xlim = c(0.1,2), #lower and upper end for x axis, cutting off points ylim = c(0.1,2), #lower and upper end for y axis las=1, bty=&quot;l&quot;) 5.4 Points How to display your data? The simplest option in a scatterplot is using points. You can manipulate them, too. 5.4.1 Shapes Default points in base R are open circles. You can change this overall: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, #see ?points for all shapes, e.g. 0 is an open square, 2,6,17 are triangles, 3,4 are crosses, 8 is a star bty = &quot;l&quot;, las = 1, cex.axis = 0.8) You can also control shapes point-by-point by giving a vector. Here, we just give all 25 possible shapes (they are recycled over all points): par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 1:25, #all shapes bty = &quot;l&quot;, las = 1, cex.axis = 0.8) That’s not very informative. But you can use the information you have to choose shapes. E.g. we can use the species information to set the shape: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = c(15:17)[as.numeric(as.factor(iris$Species))], #three shapes, subsetted by species bty = &quot;l&quot;, las = 1, cex.axis = 0.8) How does this work? The as.numeric(as.factor(iris$Species)) command first changes the column with the species names into a factor: setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, setosa, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, versicolor, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica, virginica with the levels setosa, versicolor, virginica The as.numeric part of this command then replaces every level with its number: 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 The subsetting [] then says that the first element takes the first shape (15), because it is a 1. “virginica” take the last shape (17), because they are encoded by 3. 5.4.2 Colour The same can be done with colours: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = c(&quot;blue&quot;,&quot;pink&quot;,&quot;orange&quot;)[as.numeric(as.factor(iris$Species))], #three colours, subsetted by species bty = &quot;l&quot;, las = 1, cex.axis = 0.8) R’s default colours are not the prettiest. Nice palettes are offered by several packages, one of which is RColorBrewer. Here’s an example: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], #three colours from a palette bty = &quot;l&quot;, las = 1, cex.axis = 0.8) You can also colour points by values. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = brewer.pal(9,&quot;YlGnBu&quot;)[cut(iris$Petal.Width,9)], #nine colours by petal width bty = &quot;l&quot;, las = 1, cex.axis = 0.8) Of course, you can also colour by a vector that is not used in the rest of the plot. Try it e.g. with iris$Sepal.Length. You can also increase the resolution of the color scale: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = colorRampPalette(brewer.pal(9,&quot;YlGnBu&quot;))(256)[cut(iris$Petal.Width,256)], #256 colours bty = &quot;l&quot;, las = 1, cex.axis = 0.8) 5.4.3 Size You can change the size of points, either all at the same time: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = &quot;red&quot;, cex = 2, #bigger symbols bty = &quot;l&quot;, las = 1, cex.axis = 0.8) Or depending on the group: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = &quot;red&quot;, cex = as.numeric(as.factor(iris$Species))/2, #point size by species bty = &quot;l&quot;, las = 1, cex.axis = 0.8) Or proportional to a value: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = &quot;red&quot;, cex = sqrt(iris$Petal.Length)/2, #point size by petal length bty = &quot;l&quot;, las = 1, cex.axis = 0.8) 5.4.4 Multiple sets of points You can use the points command to add more points to an existing plot. Here, we just add the same points again, but with different symbols. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, cex = sqrt(iris$Petal.Length)/4, #point size by petal length bty = &quot;l&quot;, las = 1, cex.axis = 0.8) points(iris$Petal.Length, iris$Petal.Width, pch = 1, col = &quot;green&quot;, cex = iris$Petal.Length^2/8, #point size by petal length bty = &quot;l&quot;, las = 1, cex.axis = 0.8) You can use this trick also too have tight control of all the points you plot, by not plotting them in the first plot at all: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;n&quot;, #nothing plotted bty = &quot;l&quot;, las = 1, cex.axis = 0.8) and then adding the points (here, every point is added individually - a bit of an overkill) par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;n&quot;, #nothing plotted bty = &quot;l&quot;, las = 1, cex.axis = 0.8) for(p in 1:nrow(iris)){ points(iris$Petal.Length[p], iris$Petal.Width[p], pch = sample(1:25,1), #random symbol cex = rnorm(1,1,1), #random size col = rgb(runif(1),runif(1),runif(1))) #random RGB colour } 5.5 Legends If you did not randomly attribute colours, shapes and sizes, you’ll want a legend. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], #three colours from a palette bty = &quot;l&quot;, las = 1, cex.axis = 0.8) legend(&quot;topleft&quot;, #position - there&#39;s also e.g. &quot;bottom&quot; or &quot;right&quot; legend = levels(as.factor(iris$Species)), #if you use the factors as in the plot, the names are correct col = brewer.pal(3,&quot;Dark2&quot;), #colours pch = 16, #symbol title = &quot;species&quot;, #you can have a title cex = 0.8, # smaller text and symbols bty = &quot;n&quot;) #I like to not have a box around base R legends are super-flexible: you can choose the title, the words, the symbols, their order, their size; you can put multiple legends where you want. However, you need to take care that they are correct, because R does not: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], #three colours from a palette bty = &quot;l&quot;, las = 1, cex.axis = 0.8) legend(&quot;topleft&quot;, #position - there&#39;s also e.g. &quot;bottom&quot; or &quot;right&quot; legend = c(&quot;versicolor&quot;,&quot;setosa&quot;,&quot;virginica&quot;), #wrong names col = c(&quot;grey&quot;,brewer.pal(3,&quot;Dark2&quot;)), # an extra colour? pch = 17, # not our symbol fill= &quot;grey90&quot;, #weird grey boxes border = NA, title = &quot;wrong legend&quot;, cex = 0.8, bty = &quot;n&quot;) 5.6 Lines 5.6.1 Histogram-style lines You don’t always need to have points. You can have vertical lines: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;h&quot;, #vertical lines col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8) This is not a great example, because you can’t see points that are close to each other on the x-axis. But there are uses for this. 5.6.2 Lines between points You can plot lines between all coordinates: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;l&quot;, # lines bty = &quot;l&quot;, las = 1, cex.axis = 0.8) That’s not very informative, but with a bit of sorting, this can make sense in some circumstances: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length[order(iris$Petal.Length,iris$Petal.Width)], iris$Petal.Width[order(iris$Petal.Length,iris$Petal.Width)], #both coordinates ordered first by x then y xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;l&quot;, # lines bty = &quot;l&quot;, las = 1, cex.axis = 0.8) You can see how this can be useful, if you have e.g. a time on the x-axis. You can also combine points and lines: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length[order(iris$Petal.Length,iris$Petal.Width)], iris$Petal.Width[order(iris$Petal.Length,iris$Petal.Width)], #both coordinates ordered first by x then y xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;o&quot;, # lines and points pch = 16, #filled circles lty = 3, #dash line col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))[order(iris$Petal.Length,iris$Petal.Width)]], #color (lines take the first, hm) bty = &quot;l&quot;, las = 1, cex.axis = 0.8) Like with the points command, you can also add lines to an existing plot. Let’s say we want to connect every point to a center for its species. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, #no sorting necessary xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, # back to points pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8) #center points: iris_centers &lt;- aggregate(iris[,1:4],list(iris$Species),mean) #mean value per species points(iris_centers$Petal.Length, #center points iris_centers$Petal.Width, col = brewer.pal(3,&quot;Dark2&quot;), # coloured as above pch = 1, #open circle cex = 1.5) #bit bigger for(i in 1:nrow(iris)){ #one line per point from center currSpec &lt;- iris$Species[i] #species of this point lines(x = c(iris_centers$Petal.Length[iris_centers$Group.1 == currSpec], #x coordinate of center iris$Petal.Length[i]), #x coordinate of point y = c(iris_centers$Petal.Width[iris_centers$Group.1 == currSpec], #y coordinate of center iris$Petal.Width[i]), #y coordinate of point lty = 2, #dashed line lwd = 0.6, #thinner col = brewer.pal(3,&quot;Dark2&quot;)[which(levels(as.factor(iris$Species))==currSpec)]) #appropriate color } This might be as good a moment as any to point out that you can also plot text: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, #no sorting necessary xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, # back to points pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8) #text at center points: text(iris_centers$Petal.Length, #center points iris_centers$Petal.Width, col = brewer.pal(3,&quot;Dark2&quot;), # coloured as above font = 4, #bold italic labels = iris_centers$Group.1, #species names cex = 1.5) #bit bigger 5.6.3 Lines through the plot Sometimes you want to just draw some lines at specific places. E.g. you may want to indicate a diagonal: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, #no sorting necessary xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, # back to points pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8, xlim = c(0,7), #give both axes the same range ylim = c(0,7)) #give both axes the same range abline(a=0, #diagonal, cutting y at 0 b=1, #diagonal, 45 degrees lty=3) Or some cut-off (try this with v instead of h in the abline command to get a vertical line). par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, #no sorting necessary xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, # back to points pch = 16, col = c(&quot;red&quot;,&quot;grey20&quot;)[1+as.numeric(iris$Petal.Width&gt;1.2)], #colour changes at 1.2 bty = &quot;l&quot;, las = 1, cex.axis = 0.8) #give both axes the same range abline(h=1.2, # horizontal line at 1 lty=3) 5.6.4 Trend lines You can also use these ablines to show trends: par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, #no sorting necessary xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, # back to points pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8) #linear trend for all points: abline(lm(iris$Petal.Width ~ iris$Petal.Length), #linear model col = &quot;grey30&quot;, lwd = 2) The more correct version is to use lines to limit the line to the range you observed, but it’s a lot more typing work. par(mar=c(3,3,0.5,0.5), mgp=c(1.7,0.5,0), tcl=-0.3) plot(iris$Petal.Length, iris$Petal.Width, xlab = &quot;petal length&quot;, ylab = &quot;petal width&quot;, type = &quot;p&quot;, xlim = c(0,8), #a bit bigger part of the axes to see the difference to abline ylim = c(0,3), xaxs = &quot;i&quot;, #no negative parts on the axis yaxs = &quot;i&quot;, #no negative parts on the axis pch = 16, col = brewer.pal(3,&quot;Dark2&quot;)[as.numeric(as.factor(iris$Species))], bty = &quot;l&quot;, las = 1, cex.axis = 0.8) # points to predict: new &lt;- data.frame(Petal.Length=seq(min(iris$Petal.Length), max(iris$Petal.Length), length.out = 100)) #linear trend for all points: lines(new$Petal.Length, predict(lm(Petal.Width ~ Petal.Length, data=iris), #linear model newdata = new, se.fit=T, interval = &quot;prediction&quot;)$fit[,1], col = &quot;grey30&quot;, lwd = 2) There are some more options that we could not detail today. Have a good look at ?par if you get stuck. "],["introduction-to-scatter-plots-in-rggplot2.html", "Chapter 6 Introduction to scatter plots in R/ggplot2 6.1 Setup 6.2 Scatterplots 6.3 Intermezzo: Plots as objects 6.4 Modifying plots 6.5 Legends 6.6 Lines and trends", " Chapter 6 Introduction to scatter plots in R/ggplot2 6.1 Setup In this chapter, we will use the {ggplot2} package for generating scatter plots. This package is part of the {tidyverse} package, so we will load that first: library(tidyverse) We’ll use the iris data set that comes with R. data(&quot;iris&quot;) #import like this is possible for R&#39;s inbuilt datasets head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa summary(iris) #dataset is present in the workspace with the dataset name ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## You see that you have 5 columns, with measurements of iris flowers in three species. 6.2 Scatterplots 6.2.1 Defaults We’ll use the length and widths of the petals for the x- and y-axis. The ggplot() function is used to generate the plot. But we need to define the data for x and y within aes(). Finally, we need to define the “geometry” that is used for plotting. Here we use points and to do so, we need the function geom_point(). Note that the different functions are combined with the plus sign: +. For clarity, I use a new line after each function: Let’s make a first plot: ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() 6.2.2 Themes This looks pretty good, but we can improve both the visualization and the layout. The layout can be changed with theme(). This enables full control over every element of the plot and the options can be overwhelming. Luckily, there are a few standard themes that you can use. This is an example with theme_bw(). Within the themes you can change the font size by defining base_size: ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() + theme_bw(base_size = 14) There are different themes that you can try: theme_light(), theme_classic, theme_linedraw() and theme_minimal(). You can replace the original theme in the chunk above and rerun to the effect. When axes are not informative, (e.g. NMDS, t-SNE, uMap plots), you may remove theme completely with theme_void(): ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() + theme_void(base_size = 14) This removes all theme elements and you can add them back with the theme() function: ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() + theme_void(base_size = 14) + theme(axis.title.x = element_text(color = &quot;black&quot;)) + theme(axis.title.y = element_text(color = &quot;black&quot;, angle = 90)) + theme(axis.line.x.bottom = element_line(color=&quot;black&quot;, linetype = 1, size=.5)) + theme(axis.line.y.left = element_line(color=&quot;black&quot;, linetype = 1, size=.5)) The code above shows the great level of control over the layout with theme() and that every detail can be controlled. This is however quite a daunting process and therefore it is much easier to stick with the predefined themes and modify only a couple of aspects. For instance, we can start with theme_bw() and remove the grid: ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() + theme_bw(base_size = 14)+ theme(panel.grid = element_blank()) Since the default ggplot2 theme is not ideal, you may set another theme as your default. All subsequent plots (whether you generate from an Rmarkdown file or from the console) will have this theme: theme_set(theme_bw(base_size = 14)) 6.3 Intermezzo: Plots as objects It is quite common in ggplot to assign (using &lt;-) a basic plot to an ‘object’ and after that apply/add functions to the object to modify it. This allows to quickly try a couple of variations in the command line. Let’s assign the plot shown before to the object p: p &lt;- ggplot(data = iris) + aes(x=Petal.Length, y=Petal.Width) + geom_point() + theme_bw(base_size = 14)+ theme(panel.grid = element_blank()) Note that there is no output. To display the plot we can call p: p 6.4 Modifying plots 6.4.1 Axis labels We can use the new object p to modify the axis labels: p + labs(x=&quot;Petal length&quot;, y=&quot;Petal width&quot;) To store these changes in a new object, let’s say p2 (but you can also override p) we need to assign the changes as follows: p2 &lt;- p + labs(x=&quot;Petal length&quot;, y=&quot;Petal width&quot;) To view the plot we can call p2: p2 6.4.2 Scales and ranges To set the limits of a plot, the xlim() and ylim() functions can be used: p2 + xlim(c(2,6)) + ylim(c(0,2)) ## Warning: Removed 77 rows containing missing values (geom_point). Note that we need a vector to supply the lower and upper limit of the axes. We can use NA to set the limit automatically: p2 + xlim(c(2,NA)) + ylim(c(0,2)) ## Warning: Removed 73 rows containing missing values (geom_point). Log scale can be applied (here obly to the x-axis): p2 + scale_x_log10() 6.4.3 Aesthetics &amp; Geometries Thus far, we have plotted the Petal.length and Petal.Width data as positions on the x or y-axis. This is defined in the aes() function. There are other ways to visualize data, for instance by color, shape of a symbol or its size. These so-called aesthetics can be applied in the ggplot function. The idea is that we ‘map’ data to an aesthetic. This is made explicitly in the ggplot function when we write it down in full (note that we can leave out the data = and mapping = and ggplot will still understand what we are trying to do): ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width)) By itself, this call is not sufficient to generate the plot. We need to define a geometry for plotting, e.g. geom_point(): ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width)) + geom_point() Let’s look again at the iris dataset: head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa There is a column with data on the Species. We can now map that data on an aesthetic, for instance color: ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, color=Species)) + geom_point() And we can also map that to the size of the symbols: ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, size=Species)) + geom_point() ## Warning: Using size for a discrete variable is not advised. The mapping of data on different aspects of the plotted objects (=geometries) is a very powerful concept that enables plotting of multiple parameters at the same time. To show an extreme example, (and this is probably not helping the interpretation of the data), we can display the data of all 5 columns in the iris dataset in a single plot: ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, size=Sepal.Length, color=Species, alpha=Petal.Length)) + geom_point() The properties of the geometry can also be controlled independent from the data. Here’s an example where the Species is shown as color (controlled by the aes() function) and the properties of the dots is defined in the geom_point() function: ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, color=Species)) + geom_point(size=5, alpha=0.5) The shape can also be changed and this is defined by a number. An example is given below: ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, color=Species)) + geom_point(size=5, alpha=0.5, shape=15) For more information on the possible shapes and their corresponding numbers see this page 6.5 Legends Legends are automatically added by ggplot. However, you may not always need a legend. The legend can be removed as follows: p &lt;- ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width, color=Species)) + geom_point(size=5, alpha=0.5) p + theme(legend.position = &quot;none&quot;) The appearance of the legend can be fully controlled with theme(). We can change the title, position and color of the text: p + theme(legend.position = &quot;top&quot;, legend.justification = &quot;right&quot;) + guides(color = guide_legend(title=&quot;Type:&quot;)) 6.6 Lines and trends You can plot lines between the data per Species: p + geom_line() That’s not very informative, but this could be useful for some types of data, e.g. when time is depicted on x-axis. If we were interested in trends, a trendline can be added (“lm” is an abbreviation for linear model): p + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Interestingly, it generates individual trend lines for the different Species, because we mapped the Species to a color. The trendline inherits the aesthetics that are defined in the ggplot() call. If we want to have a trendline for the combined data and keep different color for the Species, we can define the aesthetic within geom_line(), instead of ggplot(): ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width)) + geom_point(aes(color=Species), size=5, alpha=0.5) + geom_smooth(method = &quot;lm&quot;, color=&quot;black&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Note that the plot consists of multiple layers and that the last layer is the one that’s on top. So if we want to plot the data on top of the trendline, we can alter the order of geom_point() and geom_smooth(): ggplot(data = iris, mapping = aes(x=Petal.Length, y=Petal.Width)) + geom_smooth(method = &quot;lm&quot;, color=&quot;black&quot;) + geom_point(aes(color=Species), size=5, alpha=0.5) ## `geom_smooth()` using formula &#39;y ~ x&#39; "],["summarizing-distributions-in-base-r.html", "Chapter 7 Summarizing distributions in base R 7.1 Setup 7.2 The data 7.3 Just the mean: Barplots 7.4 Medians, quartiles, and outliers: Boxplots 7.5 Histograms 7.6 Density plots 7.7 Violinplots 7.8 Beanplots", " Chapter 7 Summarizing distributions in base R 7.1 Setup In this chapter, we take a look at R functions in the base packages that can summarize values. We will use some additional packages for specialized functions. if(!require(vioplot)){ install.packages(&quot;vioplot&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(vioplot) } ## Loading required package: vioplot ## Loading required package: sm ## Package &#39;sm&#39;, version 2.2-5.7: type help(sm) for summary information ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric if(!require(beanplot)){ install.packages(&quot;beanplot&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(beanplot) } ## Loading required package: beanplot if(!require(RColorBrewer)){ install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(RColorBrewer) } if(!require(gplots)){ install.packages(&quot;gplots&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(gplots) } ## Loading required package: gplots ## ## Attaching package: &#39;gplots&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## lowess 7.2 The data For the visualizations we use the ChickWeight data set that comes with R. data(&quot;ChickWeight&quot;) #import like this is possible for R&#39;s inbuilt datasets head(ChickWeight) ## Grouped Data: weight ~ Time | Chick ## weight Time Chick Diet ## 1 42 0 1 1 ## 2 51 2 1 1 ## 3 59 4 1 1 ## 4 64 6 1 1 ## 5 76 8 1 1 ## 6 93 10 1 1 summary(ChickWeight) #dataset is present in the workspace with the dataset name ## weight Time Chick Diet ## Min. : 35.0 Min. : 0.00 13 : 12 1:220 ## 1st Qu.: 63.0 1st Qu.: 4.00 9 : 12 2:120 ## Median :103.0 Median :10.00 20 : 12 3:120 ## Mean :121.8 Mean :10.72 10 : 12 4:118 ## 3rd Qu.:163.8 3rd Qu.:16.00 17 : 12 ## Max. :373.0 Max. :21.00 19 : 12 ## (Other):506 You see that you have 4 columns, most importantly weight. There are 3 sets of ‘metadata’: when was a chick weighed, which chick, and what was the chick eating. Let’s plot all of the chick data. plot(ChickWeight$Time, ChickWeight$weight, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;) This is not very pretty and we’re missing some information. Let’s clean it up a bit: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels plot(ChickWeight$Time, ChickWeight$weight, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols col=brewer.pal(4,&quot;Dark2&quot;)[as.numeric(as.factor(ChickWeight$Diet))], #color by diet las=1, #all axis marks horizontal bty=&quot;l&quot;) #just the x and y axis, no box legend(&quot;topleft&quot;, #legend, position legend = levels(as.factor(ChickWeight$Diet)), #names of diet pch=16, #filled points like plot col=brewer.pal(4,&quot;Dark2&quot;), #colours like plot title = &quot;diet&quot;, #legend title bty=&quot;n&quot;) #no box around legend This looks nice, but the points are still overlapping, so we don’t see really well how they are distributed. 7.3 Just the mean: Barplots One of the simplest summary values you may want to plot is the mean. You can visualize the mean of different groups using bar plots. For now, we are ignoring the different diets. Let’s look at all chicks’ weights at time 0: summary(ChickWeight$weight[ChickWeight$Time==0]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 39.00 41.00 41.00 41.06 42.00 43.00 and at time 10: summary(ChickWeight$weight[ChickWeight$Time==10]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 51.0 93.0 109.0 107.8 124.0 163.0 We can calculate the mean chick weight per time point using the aggregate function, which will aggregate any set of values (here ChickWeight$weight i.e. the column with weights) according to a factor (here list(ChickWeight$Time) i.e. the time points) using a function of our choice (here mean). chickWeightTime &lt;- aggregate(ChickWeight$weight,list(ChickWeight$Time),mean) colnames(chickWeightTime) &lt;- c(&quot;Time&quot;,&quot;weight&quot;) #clean up names head(chickWeightTime) ## Time weight ## 1 0 41.06000 ## 2 2 49.22000 ## 3 4 59.95918 ## 4 6 74.30612 ## 5 8 91.24490 ## 6 10 107.83673 We could plot as a scatter plot, since the time points are not categories but real values: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels plot(chickWeightTime$Time, chickWeightTime$weight, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1, #all axis marks horizontal bty=&quot;l&quot;) #just the x and y axis, no box 7.3.1 Simple barplots Now we plot the barplot: barplot(chickWeightTime$weight, names.arg = chickWeightTime$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;) An important difference in the scatter plot and the bar plot is the y-axis default: scatter plot’s axes are scaled to the values, while the bar plot starts at 0 (if there are only positive data). While sort of informative, base R barplots tend to be rather ugly. Compared to scatterplots, they need a lot of tweaking to look kind of nice. Here are some options: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels barplot(chickWeightTime$weight, names.arg = chickWeightTime$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, las = 1, # all letters horizontal ylim = c(0,1.1*max(chickWeightTime$weight)), #y-axis that is longer than the longest bar yaxs = &quot;r&quot;, cex.axis = 0.8, #smaller y-axis annotation cex.names = 0.8 #smaller x-axis annotation ) Sometimes, you want the bar plot to look more like all other plots: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels bars &lt;- barplot(chickWeightTime$weight, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, las = 1, # all letters horizontal ylim = c(0,1.1*max(chickWeightTime$weight)), #y-axis that is longer than the longest bar yaxs = &quot;i&quot;, #x-axis to cut y axis at 0 cex.axis = 0.8, #smaller y-axis annotation space = 0.4, #leaner bars col = &quot;grey30&quot;, #color of the bars border = NA #no borders on the bars ) axis(1, #add x-axis at = bars[,1], #get mid points from plot function above labels = chickWeightTime$Time, cex.axis = 0.8) #smaller x-axis annotation box(&quot;plot&quot;,bty=&quot;l&quot;) #add box (x-axis) 7.3.2 Barplots with error bars Base R barplots are not designed to have automatic error bars. barplot2 from the gplots package does the trick, though. First, let’s calculate the standard deviation (sd) of each mean: chickWeightTime$sd &lt;- aggregate(ChickWeight$weight,list(ChickWeight$Time),sd)[,2] # here, we calculate sd and just append it as another column (named sd) to the previous table # we can do this, because the first two arguments of aggregate and the aggregated data.frame are the same as before, so the output will have the same order Now, we plot as above, but with the barplot2 function. This takes the arguments ci.l and ci.u which were originally conceived for confidence intervals (hence we still need to calculate where we want them to sit). par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels bars &lt;- barplot2(chickWeightTime$weight, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, las = 1, # all letters horizontal ylim = c(0,1.1*max(chickWeightTime$weight + chickWeightTime$sd)), #y-axis that is longer than the longest bar, incl error yaxs = &quot;i&quot;, #x-axis to cut y axis at 0 cex.axis = 0.8, #smaller y-axis annotation space = 0.4, #leaner bars col = &quot;grey30&quot;, #color of the bars border = NA, #no borders on the bars plot.ci = T, #error bars need to be enabled explicitly ci.l = chickWeightTime$weight - chickWeightTime$sd, # lower error bar ci.u = chickWeightTime$weight + chickWeightTime$sd # upper error bar ) axis(1, #add x-axis at = bars[,1], #get mid points from plot function above labels = chickWeightTime$Time, cex.axis = 0.8) #smaller x-axis annotation box(&quot;plot&quot;,bty=&quot;l&quot;) #add box (x-axis) There’s no standard for which value should be reflected by error bars. In many fields, mean ± standard deviation are common, but sometimes you also see mean ± standard error of the mean (sd devided by n). In other fields you’ll more commonly have a mean and a confidence interval, e.g. 95%. Finally, you could plot medians and interquartile ranges. But then, you’ve got a poor man’s boxplot. 7.4 Medians, quartiles, and outliers: Boxplots 7.4.1 Basic boxplots Boxplots have become the go-to visualization for many questions, because they give more information about data distribution than barplots. R calculates all the necessary summative values from the raw data, meaning we need to supply the whole data to the boxplot function (not the means as we did above). The values that are depicted by default are: the median (big bar in the middle = the 50th percentile) the 25th and 75 percentiles (ends of the box = quartiles) the whiskers extend to the last points within 1.5 * IQR from the quartiles (IQR is the interquartile range, i.e. the range between the box’s ends) all points that lie outside are plotted as points (outliers) Here we go: boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;) The default is already quite informative. We can make it a bit more pretty, if necessary, e.g.: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal We can add the number of observations per box: par(mar=c(3,3,1,0.5), #different margins ! tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal #numbers of observations: axis(3, #on a top axis at=1:length(levels(as.factor(ChickWeight$Time))), #at the coordinates of the boxes labels=table(ChickWeight$Time), #numbers of observations per timepoints cex.axis=0.8, #smaller letters tcl=0, #no ticks mgp=c(0,0,0)) #no distance to plot mtext(&quot;N=&quot;,#N= as axis label 3, #on top of the plot 0, # no distance to plot cex = 0.8, #smaller letters adj = 0) #at the left end of the axis 7.4.2 Adding points on top Now, we have a nice summary. However, it’s not visible whether the boxes are good approximations for the distribution of the data points. We can therefore add points to the boxes. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal points(as.numeric(as.factor(ChickWeight$Time)),#this uses the time like the boxplot does ! ChickWeight$weight, #the y-values cex=0.6, #make points a bit smaller pch=16) #fill points This is better, but the points are still overlapping. A simple way of dealing with that is to add a jitter. This is a random value which moves the points apart. We’re only applying it in x-direction (within a box), so the y-values are precise. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1, #all axis marks horizontal outline=F) #don&#39;t plot outliers, because they are added later points(jitter(as.numeric(as.factor(ChickWeight$Time)),amount = 0.25),#jitter added ! ChickWeight$weight, #the y-values cex=0.6, #make points a bit smaller pch=16) #fill points There are still some unfortunate collisions, but it’s much clearer. We can also sort the points to be more nicely arranged, but this is a bit more work. In the chunk below, we first define a function smartJitter which can do this in most situations. smartJitter &lt;- function(x=NULL,y=NULL,modelFrame=NULL,cex.point=0.2,boxwex=0.8){ pointheight &lt;- abs(par(&quot;usr&quot;)[4]-par(&quot;usr&quot;)[3]) / ( par(&quot;pin&quot;)[2]*72/(par(&quot;ps&quot;)*cex.point) ) pointwidth &lt;- abs(par(&quot;usr&quot;)[2]-par(&quot;usr&quot;)[1]) / ( par(&quot;pin&quot;)[1]*72/(par(&quot;ps&quot;)*cex.point) ) boxwidth &lt;- par(&quot;pin&quot;)[1]*72*boxwex/(par(&quot;ps&quot;)*cex.point) / par(&quot;xaxp&quot;)[2] if(!is.null(x) &amp; !is.null(y)){ dat &lt;- data.frame(&quot;x&quot;=x,&quot;y&quot;=y,&quot;pos&quot;=1:length(x),stringsAsFactors = F) }else{ if(!is.null(modelFrame)){ dat &lt;- data.frame(&quot;x&quot;=as.numeric(as.factor(modelFrame[,2])), &quot;y&quot;=modelFrame[,1], &quot;pos&quot;=1:nrow(modelFrame),stringsAsFactors = F) } } datls &lt;- aggregate(dat$y,list(dat$x),c,simplify = F)$x datps &lt;- aggregate(dat$pos,list(dat$x),c,simplify = F)$x datl &lt;- lapply(datls,sort) datr &lt;- lapply(datls,function(x) rank(x,ties.method = &quot;last&quot;)) dato &lt;- lapply(datls,order) datops &lt;- lapply(1:length(dato), function(x) datps[[x]][dato[[x]]]) binl &lt;- lapply(datl, function(x) cut(x, breaks=max(2,round(abs(max(x)-min(x))/pointheight)))) xoffl &lt;- lapply(lapply(binl, function(y){ table(y)[table(y)&gt;0] }), function(x){ unlist(sapply(x, function(z) { as.numeric(rbind(seq(0,by=pointwidth,length.out=z/2), -seq(pointwidth,by=pointwidth, length.out=z/2)))[1:z] }))}) xo &lt;- dat$x + unlist(xoffl)[order(unlist(datops))] yo &lt;- unlist(datl)[order(unlist(datops))] cbind(xo,yo) } par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1, #all axis marks horizontal outline=F) #don&#39;t plot outliers, because they are added later points(smartJitter(modelFrame=model.frame(ChickWeight$weight ~ ChickWeight$Time)),# swarms added! cex=0.45, #make points a bit smaller pch=16) #fill points Because the points are very close together at the early time points, they overlap with each other, but overall this is quite clean. Now, finally, we could add back the colours of the experimental groups. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1, #all axis marks horizontal outline=F) #don&#39;t plot outliers, because they are added later points(smartJitter(modelFrame=model.frame(ChickWeight$weight ~ ChickWeight$Time)),#jitter added cex=0.45, #make points a bit smaller pch=16,#fill points col=brewer.pal(4,&quot;Dark2&quot;)[as.numeric(as.factor(ChickWeight$Diet))]) #color by diet! legend(&quot;topleft&quot;, #legend!, position legend = levels(as.factor(ChickWeight$Diet)), #names of diet pch=16, #filled points like plot pt.cex = 0.45, col=brewer.pal(4,&quot;Dark2&quot;), #colours like plot title = &quot;diet&quot;, #legend title bty=&quot;n&quot;) #no box around legend 7.4.3 Adding lines between points The colours above already help with seeing the different trends in the diet treatments. We could also aid our audience with some lines. For this, we need to draw one set of lines per chick through all time points. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Time, xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1, #all axis marks horizontal outline=F) #don&#39;t plot outliers, because they are added later #lines:! quiet &lt;- sapply(unique(ChickWeight$Chick), #the quiet is a dirty trick to suppress console output function(chick){ #per chcick, do chickdiet &lt;- unique(as.numeric(as.factor(ChickWeight$Diet))[ChickWeight$Chick==chick]) #which diet did our chick have? lines(x = as.numeric(as.factor(ChickWeight$Time))[ChickWeight$Chick==chick], #time points for this chick y = ChickWeight$weight[ChickWeight$Chick==chick], #weights lty=1, lwd=0.3, #thin lines col=brewer.pal(4,&quot;Dark2&quot;)[chickdiet]) #colour by diet }) points(smartJitter(modelFrame=model.frame(ChickWeight$weight ~ ChickWeight$Time)),#jitter added cex=0.45, #make points a bit smaller pch=16,#fill points col=brewer.pal(4,&quot;Dark2&quot;)[as.numeric(as.factor(ChickWeight$Diet))]) #color by diet legend(&quot;topleft&quot;, #legend, position legend = levels(as.factor(ChickWeight$Diet)), #names of diet pch=16, #filled points like plot pt.cex = 0.45, col=brewer.pal(4,&quot;Dark2&quot;), #colours like plot title = &quot;diet&quot;, #legend title bty=&quot;n&quot;) #no box around legend 7.4.4 Half-boxes In the previous examples, we split our data by one factor (time point) to make boxes. Sometimes, there is more than one factor of interest. For example, we could want to make one set of boxes for chicken with control diet (diet 1) and another set for the other diets. #add a column saying whether we have the control or treatment ChickWeight$Treat &lt;- ifelse(test = ChickWeight$Diet == 1, #assign a new vector, depending on whether diet is 1 yes = &quot;1&quot;, #if yes, use 1 no = &quot;2-3-4&quot;) #else, use 2-3-4 We can then use both the treatment and the time factor for plotting: par(mar=c(5,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Treat + ChickWeight$Time, #both factors! xlab = &quot;&quot;, #no x-axis label because the axis marks are too long ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=2) #all axis marks orthogonal to the axis! mtext(&quot;diet . timepoint&quot;, #add axis label manually! side = 1, #to x-axis line = 3.8) # a bit away Here is a good moment to mention that you can also manipulate the width of the boxes, e.g. to indicate different group sizes: par(mar=c(5,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels boxplot(ChickWeight$weight ~ ChickWeight$Treat + ChickWeight$Time, xlab = &quot;&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=2,#all axis marks orthogonal to the axis varwidth=T) #box widths are proportional to square root of number of data points mtext(&quot;diet . timepoint&quot;,side = 1,line = 3.8) Another option is to split the boxes per time point. This is not a standard R function, but can be done by slightly changing the standard boxplot function. This happens in the next chunk - the code is long, so it will not be reproduced in the knitted document. We plot both halves using information from the boxplot function: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels #left half of the boxes: bxpL(boxplot(ChickWeight$weight[ChickWeight$Treat==&quot;1&quot;] ~ ChickWeight$Time[ChickWeight$Treat==&quot;1&quot;], plot=F), #plot only diet 1 ylim=c(min(ChickWeight$weight),max(ChickWeight$weight)), #overall y-axis range whisklty=&quot;solid&quot;, #whiskers axes=F, #no axes (we add them later) xlab=&quot;time point&quot;, #x axis label ylab=&quot;weight&quot;,#y axis label bgcol=&quot;white&quot;,#white box border=brewer.pal(4,&quot;Dark2&quot;)[1], #green box pch=16, #filled outliers cex=0.7) #slightly smaller points #right half of the boxes: par(new=T) #to prevent starting a new plot bxpR(boxplot(ChickWeight$weight[ChickWeight$Treat!=&quot;1&quot;] ~ ChickWeight$Time[ChickWeight$Treat!=&quot;1&quot;], plot=F), #plot the non-control diets ylim=c(min(ChickWeight$weight),max(ChickWeight$weight)),#overall y-axis range same as above whisklty=&quot;solid&quot;,#whiskers axes=F, #no axes bgcol=&quot;grey80&quot;, #grey box pch=16, #filled outliers cex=0.7) #slightly smaller points #everything around: axis(1, #x-axis at=c(1:length(levels(as.factor(ChickWeight$Time)))), #in the middle of the boxes lab=levels(as.factor(ChickWeight$Time)), #with labels from timepoints las=1, #horizontal letters lwd=0, #no ticks cex.axis=0.8) #slightly smaller letters axis(2, #y-axis las=1, #horizontal letters cex.axis=0.8) #slightly smaller letters box(lwd=1) #frame around the plot legend(&quot;topleft&quot;, #legend legend=c(&quot;1&quot;,&quot;2,3,4&quot;), #words title = &quot;diet&quot;, #title fill=c(&quot;white&quot;,&quot;grey80&quot;),#colours from boxes border = c(brewer.pal(4,&quot;Dark2&quot;)[1],&quot;black&quot;), #box colours bty=&quot;n&quot;) #no box We can also add the points and lines as before: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0))#move axis labels #left half of the boxes: bxpL(boxplot(ChickWeight$weight[ChickWeight$Treat==&quot;1&quot;] ~ ChickWeight$Time[ChickWeight$Treat==&quot;1&quot;], plot=F), #plot only diet 1 outline=F, #no outliers (we add them later) ylim=c(min(ChickWeight$weight),max(ChickWeight$weight)), #overall y-axis range whisklty=&quot;solid&quot;, #whiskers axes=F, #no axes (we add them later) xlab=&quot;time point&quot;, #x axis label ylab=&quot;weight&quot;,#y axis label bgcol=&quot;white&quot;) #white box #right half of the boxes: par(new=T) #to prevent starting a new plot bxpR(boxplot(ChickWeight$weight[ChickWeight$Treat!=&quot;1&quot;] ~ ChickWeight$Time[ChickWeight$Treat!=&quot;1&quot;], plot=F), #plot the non-control diets outline=F, #no outliers (we add them later) ylim=c(min(ChickWeight$weight),max(ChickWeight$weight)),#overall y-axis range same as above whisklty=&quot;solid&quot;,#whiskers axes=F, #no axes bgcol=&quot;grey80&quot;) #grey box #everything around: axis(1, #x-axis at=c(1:length(levels(as.factor(ChickWeight$Time)))), #in the middle of the boxes lab=levels(as.factor(ChickWeight$Time)), #with labels from timepoints las=1, #horizontal letters lwd=0, #no ticks cex.axis=0.8) #slightly smaller letters axis(2, las=1, #horizontal letters cex.axis=0.8) #slightly smaller letters box(lwd=1) #frame around the plot legend(&quot;topleft&quot;, #legend legend=c(&quot;1&quot;,&quot;2,3,4&quot;), #words title = &quot;diet&quot;, #title fill=c(&quot;white&quot;,&quot;grey80&quot;),#colours from boxes bty=&quot;n&quot;) #no box #lines (as before): quiet &lt;- sapply(unique(ChickWeight$Chick), #the quiet is a dirty trick to suppress console output function(chick){ #per chcick, do chickdiet &lt;- unique(as.numeric(as.factor(ChickWeight$Diet))[ChickWeight$Chick==chick]) #which diet did our chick have? lines(x = as.numeric(as.factor(ChickWeight$Time))[ChickWeight$Chick==chick]+ c(-0.25,0.25)[1+as.numeric(ChickWeight$Ctrl)[ChickWeight$Chick==chick]], #time points for this chick y = ChickWeight$weight[ChickWeight$Chick==chick], #weights lty=1, lwd=0.3, #thin lines col=brewer.pal(4,&quot;Dark2&quot;)[chickdiet]) #colour by diet }) #points: - this time we give the coordinates to a variable first jitteredPoints &lt;- smartJitter(modelFrame=model.frame(ChickWeight$weight ~ ChickWeight$Time)) # jittered coordinates points(jitteredPoints[,1] + c(0.25,-0.25)[1+as.numeric(ChickWeight$Treat==1)], #move left or right, depending on treatment jitteredPoints[,2], #keep y-position cex=0.45, #make points a bit smaller pch=16,#fill points col=brewer.pal(4,&quot;Dark2&quot;)[as.numeric(as.factor(ChickWeight$Diet))]) #color by diet 7.5 Histograms From what you’ve read above about the values that the boxplot represents, you can already tell that it is more appropriate for unimodal distributions - that is, distributions that have most values in the middle. To see this, let’s focus on the chicken data from the first and third week and look at diet 3 only. ChickWeight_3 &lt;- ChickWeight[ ChickWeight$Time %in% c(0,2,4,6,16,18,20,21) &amp;#subset of days ChickWeight$Diet==3 ,] #and diet 3 An easy way to visualize distributions as histograms: hist(ChickWeight_3$weight) As usual, the default is ugly, but with a few additional arguments, this becomes a useful view: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels hist(ChickWeight_3$weight, xlab = &quot;weight&quot;, ylab = &quot;counts&quot;, main=&quot;&quot;, #no title, this is in the axis labels cex.axis=0.8, #smaller axis annotation las=1, #all axis marks horizontal yaxs = &quot;i&quot;, #x-axis to cut y axis at 0 ) box(&quot;plot&quot;,bty=&quot;l&quot;) Okay, so what you see are two humps of values. This because one hump contains the values from the first week and the other contains the values of the second week. In real life, you’d not want to throw these two sets of values into the same plot, because you know they don’t belong together. But bear with us for a moment. If you plot these values as a single boxplot box, this is what it looks like: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels boxplot(ChickWeight_3$weight, xlab = &quot;demo subset&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal Without points plotted, you’d never guess what the distribution was. To clarify this, in the following plot, we add the quartiles and where whiskers would lie in the histogram: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels hist(ChickWeight_3$weight, xlab = &quot;weight&quot;, ylab = &quot;counts&quot;, main=&quot;&quot;, #no title, this is in the axis labels cex.axis=0.8, #smaller axis annotation las=1, #all axis marks horizontal yaxs = &quot;i&quot;, #x-axis to cut y axis at 0 ) box(&quot;plot&quot;,bty=&quot;l&quot;) abline(v=median(ChickWeight_3$weight),lwd=3) #median abline(v=quantile(ChickWeight_3$weight,c(0.25,0.75)),lwd=1) #quartiles abline(v=boxplot(ChickWeight_3$weight,plot = F)$stats[c(1,5),],lwd=1,lty=2) # whiskers So, you see, the median lies at a place where there are no values at all. The histogram therefore gives a better visualization of this distribution. But it represents just one sample and overlaying several barplots or histograms would look clunky. 7.6 Density plots One way of dealing with this is described in the next sections. R can smooth histograms and plot the smoothed line as density plot: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels plot(density(ChickWeight_3$weight,from=0), xlab = &quot;weight&quot;, ylab = &quot;density&quot;, main=&quot;&quot;, #no title, this is in the axis labels cex.axis=0.8, #smaller axis annotation las=1, #all axis marks horizontal yaxs = &quot;i&quot; #x-axis to cut y axis at 0 ) One thing to keep in mind is the number of observations you need. To estimate such a smooth line, you want many points (a few hundred are better than 10). But R will do its best and plot a (maybe deceiving) line down to 2 points. You cant try this out below, by replacing the 80 (all available points) with smaller numbers (less points): par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels plot(density( #the density function ChickWeight_3$weight[sample(1:length(ChickWeight_3$weight), #we take a random sample of the weights 80)], # sample size -&gt; change this value from=0), xlab = &quot;weight&quot;, ylab = &quot;density&quot;, main=&quot;&quot;, #no title, this is in the axis labels cex.axis=0.8, #smaller axis annotation las=1, #all axis marks horizontal yaxs = &quot;i&quot; #x-axis to cut y axis at 0 ) 7.7 Violinplots Violinplots use a similar smoothing as the density plot above. But then, they flip the graph by 90 degrees and mirror it. This gives a violin shape for distributions that are bimodal as the one above. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels vioplot(ChickWeight_3$weight, names = &quot;demo subset&quot;, drawRect = F, col=&quot;white&quot;, xlab = &quot;&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal By default, violinplots are actually endowed with a tiny boxplot in the middle: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels vioplot(ChickWeight_3$weight, names = &quot;demo subset&quot;, xlab = &quot;&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal If you put several of these next to each other, you have a plot like a boxplot, but instead of only boxes you have violins, which are better at showing distributions: ChickWeight_2 &lt;- ChickWeight[ ChickWeight$Time %in% c(0,2,4,6,16,18,20,21) &amp;#subset of days ChickWeight$Diet==2 ,] #and diet 2 par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels vioplot(cbind(ChickWeight_2$weight,ChickWeight_3$weight), names = c(&quot;2&quot;,&quot;3&quot;), xlab = &quot;diet&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal You can use violinplots pretty much like boxplots, when it comes to coding. Here, you see our example from the boxplot section, as violinplots. Only the function name boxplot needed to be changed to vioplot. par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels vioplot(ChickWeight$weight ~ ChickWeight$Time, #only the function changed here! xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal quiet &lt;- sapply(unique(ChickWeight$Chick), #the quiet is a dirty trick to suppress console output function(chick){ #per chick, do chickdiet &lt;- unique(as.numeric(as.factor(ChickWeight$Diet))[ChickWeight$Chick==chick]) #which diet did our chick have? lines(x = as.numeric(as.factor(ChickWeight$Time))[ChickWeight$Chick==chick], #time points for this chick y = ChickWeight$weight[ChickWeight$Chick==chick], #weights lty=1, lwd=0.3, #thin lines col=brewer.pal(4,&quot;Dark2&quot;)[chickdiet]) #colour by diet }) points(smartJitter(modelFrame=model.frame(ChickWeight$weight ~ ChickWeight$Time)),#jitter added cex=0.45, #make points a bit smaller pch=16,#fill points col=brewer.pal(4,&quot;Dark2&quot;)[as.numeric(as.factor(ChickWeight$Diet))]) #color by diet legend(&quot;topleft&quot;, #legend, position legend = levels(as.factor(ChickWeight$Diet)), #names of diet pch=16, #filled points like plot pt.cex = 0.45, col=brewer.pal(4,&quot;Dark2&quot;), #colours like plot title = &quot;diet&quot;, #legend title bty=&quot;n&quot;) #no box around legend 7.8 Beanplots An alternative to violinplots are beanplots. These are kind of useful, if we have two groups of samples whose distribution should be compared over different levels. Here is an example, comparing diet 1 (the control diet) to the other diets: par(mar=c(3,3,0.5,0.5), #different margins tcl=-0.3, #shorter tick marks mgp=c(1.9,0.5,0)) #move axis labels beanplot(lapply(split(ChickWeight, ~ Treat + Time),function(x) x$weight), # !different format what=c(F,T,T,F), #undocumente option side = &quot;both&quot;, #two sides col = list(brewer.pal(4,&quot;Dark2&quot;)[1],&quot;grey&quot;), xlab = &quot;time point&quot;, ylab = &quot;weight&quot;, cex.axis=0.8, #smaller axis annotation pch=16, #filled symbols las=1) #all axis marks horizontal legend(&quot;topleft&quot;, #legend, position legend = c(&quot;control&quot;,&quot;2,3,4&quot;), #names of diet fill=c(brewer.pal(4,&quot;Dark2&quot;)[1],&quot;grey&quot;), #colours like plot title = &quot;diet&quot;, #legend title bty=&quot;n&quot;) #no box around legend While this is an interesting idea, there are a few problems with this implementation: the density lines are not calculated in the most appropriate way (you can see the distributions reaching below 0, which can’t be true) the way the groups are defined is inflexible the function is brutally badly documented (you need to read the code to find the arguments and you get error messages if you try to open the help) "],["distributions-ggplot2.html", "Chapter 8 Distributions &amp; ggplot2 8.1 Setup and data 8.2 Multiple distributions 8.3 Boxplots 8.4 Violinplots 8.5 Facets: Splitting into multiple plots 8.6 A single distribution 8.7 Two distributions", " Chapter 8 Distributions &amp; ggplot2 8.1 Setup and data Let’s load the {tidyverse} package, which includes the {ggplot2} package that we will use for plotting: library(tidyverse) For the first set of visualizations, we use the ChickWeight data set that comes with R. Let’s look at the first few lines: head(ChickWeight) ## Grouped Data: weight ~ Time | Chick ## weight Time Chick Diet Treat ## 1 42 0 1 1 1 ## 2 51 2 1 1 1 ## 3 59 4 1 1 1 ## 4 64 6 1 1 1 ## 5 76 8 1 1 1 ## 6 93 10 1 1 1 It can be useful to look at the last lines as well: tail(ChickWeight) ## Grouped Data: weight ~ Time | Chick ## weight Time Chick Diet Treat ## 573 155 12 50 4 2-3-4 ## 574 175 14 50 4 2-3-4 ## 575 205 16 50 4 2-3-4 ## 576 234 18 50 4 2-3-4 ## 577 264 20 50 4 2-3-4 ## 578 264 21 50 4 2-3-4 To summarize the dataset: summary(ChickWeight) #dataset is present in the workspace with the dataset name ## weight Time Chick Diet Treat ## Min. : 35.0 Min. : 0.00 13 : 12 1:220 Length:578 ## 1st Qu.: 63.0 1st Qu.: 4.00 9 : 12 2:120 Class :character ## Median :103.0 Median :10.00 20 : 12 3:120 Mode :character ## Mean :121.8 Mean :10.72 10 : 12 4:118 ## 3rd Qu.:163.8 3rd Qu.:16.00 17 : 12 ## Max. :373.0 Max. :21.00 19 : 12 ## (Other):506 8.2 Multiple distributions 8.2.1 Plotting the data You see that you have 4 columns, most importantly weight. There are 3 columns with ‘metadata’: the Time that a chick weighed, which Chick, and its Diet. Let’s plot the weight versus Time: ggplot(data = ChickWeight, aes(x=Time, y=weight)) + geom_point() Let’s change the defauklt theme to set the background of the plot panel to white: theme_set(theme_light(base_size = 14)) The points are overlapping. To reduce overlap, we can introduce random displacement, also known as jitter. The width can be used to control the amount of jitter: ggplot(data = ChickWeight, aes(x=Time, y=weight)) + geom_jitter() Since there is still overlap, the dots can be made more transparent: ggplot(data = ChickWeight, aes(x=Time, y=weight)) + geom_jitter(width = 0.25, alpha=0.5) 8.3 Boxplots There are several ways to summarize the distribution of the data. The most common are barplots, boxplots and violinplots. The barplot is an over simplication of the data that only depicts the average. This type of summary should be avoided, see here for more about that. Boxplots and violinplots are better suited as summaries. In a boxplot, the values that are depicted by default are: the median (big bar in the middle = the 50th percentile) the 25th and 75 percentiles (ends of the box = quartiles) the whiskers extend to the last points within 1.5 * IQR from the quartiles (IQR is the interquartile range, i.e. the range between the box’s ends) all points that lie outside are plotted as points (outliers) Here we go: ggplot(data = ChickWeight, aes(x=Time, y=weight)) + geom_boxplot() ## Warning: Continuous x aesthetic -- did you forget aes(group=...)? In the plot above, all data is used for the summary, so we should indicate that we want to group the data by time: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_boxplot() Since different data distribution can give rise to the same boxplot, it is still useful to plot the data: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_jitter(width = 0.25, alpha=0.5) + geom_boxplot() The boxplot is now on top of the data. This can be solved by changing the order of the the layers or by changing the fill color of the boxplot: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_jitter(width = 0.25, alpha=0.5) + geom_boxplot(fill=NA) One other thing needs to be fixed. The outliers are plotted twice. Once as a jittered dot and once as outlier of the boxplot. To remove the outlier from the boxplot we use: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_jitter(width = 0.25, alpha=0.5) + geom_boxplot(fill=NA, outlier.shape = NA) This graph looks a bit funny, since the Time points are not equally spaced. There is a difference of 2 for almost all, execpt for the last two time points which are 20 and 21. When there is continuous data on the x-axis (e.g. time, length, concentration) it makes sense to use those data for the x-axis position. However, we could also treat the x-axis data as labels or categories (instead of numbers). This would result in equal spacing, although the values are not equally spaced. To do this, we need to convert the Time data to a ‘factor.’ This can be done in the dataset or directly in the ggplot command as shown below: ggplot(data = ChickWeight, aes(x=as.factor(Time), y=weight, group=Time)) + geom_jitter(width = 0.25, alpha=0.5) + geom_boxplot(fill=NA, outlier.shape = NA) Another explanation of discrete versus quantitative data on the x-axis with ggplot example code can be found here. The boxplot is a summary of the data that shows the midpoint of the data (median = middle line), the middle 50% of the data (the box) and the extremes with the whiskers. The exact defenition can vary between the different whiskers, to it’s a good idea to check that. From the geom_boxplot() webpage: “The upper whisker extends from the hinge to the largest value no further than 1.5 * IQR from the hinge (where IQR is the inter-quartile range, or distance between the first and third quartiles). The lower whisker extends from the hinge to the smallest value at most 1.5 * IQR of the hinge. Data beyond the end of the whiskers are called”outlying” points and are plotted individually.” 8.4 Violinplots To better summarize the distribution, a violinplot can be displayed: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) If desired the quantiles can be displayed. These can be user-defined and here we use the quartiles that corresponds to the horizontal lines that define the boxplot. So the middle line is the median: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;, draw_quantiles = c(0.25,0.5,0.75)) Another option is to combine a boxplot with a violinplot to display the quartiles: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_boxplot(fill=&quot;white&quot;, outlier.shape = NA, width=0.2) To combine the violinplot with the data: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_jitter(width = 0.25, alpha=0.5) The data are acquired for different Diets so we can map that data to different colors: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_jitter(width = 0.25, alpha=0.5, aes(color=Diet)) 8.5 Facets: Splitting into multiple plots Let’s say we want to compare the weight for different diets. In ggplot there is a way to ‘split’ the data and show it in multiple graphs. The simplest function is facet_wrap() and let’s see how that works: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_jitter(width = 0.25, alpha=0.5, aes(color=Diet)) + facet_wrap(~Diet) The facet_wrap() function calculates the optimal layout, but it can be defined by ncol (or nrow): ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_jitter(width = 0.25, alpha=0.5, aes(color=Diet)) + facet_wrap(~Diet, ncol = 4) The use of facet_wrap() is particularly powerful when the data has several conditions. Another, similar function, is facet_grid() which allows splitting the data according to two parameters: ggplot(data = ChickWeight, aes(x=Time, y=weight, group=Time)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey&quot;) + geom_jitter(width = 0.25, alpha=0.5, aes(color=Diet)) + facet_grid(Diet~Time, scales = &quot;free_x&quot;) + theme(axis.text.x = element_blank()) #Removes the Time labels from the x-axis In the example here, it may not be the best idea to split the Time in different plots, but it illustrates how facet_grid() can be used. 8.6 A single distribution Let’s have a look at the combined data of the first and last week from diet 3. This can be achieved in multiple ways. For instance we can generate a new dataframe. But we can also filter the data and feed it directly into ggplot with the pipe operator: ChickWeight %&gt;% filter(Diet==3) %&gt;% filter(Time %in% c(0,2,4,6,16,18,20,21)) %&gt;% ggplot(aes(x=Diet, y=weight)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey90&quot;) + geom_jitter(width = 0.25, alpha=1, size=5) To generate a new dataframe: ChickWeight_sub &lt;- ChickWeight %&gt;% filter(Diet==3) %&gt;% filter(Time %in% c(0,2,4,6,16,18,20,21)) 8.6.1 A single violinplot Since we have combined data from the first and last week, we see a bimodal distribution. This is nicely visualized with the violinplot. The violinplot shows the distribution of the data between the two extremes. The violinplot shows the estimated density distribution of the data. This ranges from the minimal to the maximal value of the data. To extrapolate the distribution we can use trim=FALSE: ggplot(ChickWeight_sub, aes(x=Diet, y=weight)) + geom_violin(scale = &quot;width&quot;, fill=&quot;grey90&quot;, trim = FALSE) + geom_jitter(width = 0.25, alpha=1, size=5) 8.6.2 Density plot The violinplot is much like a smoothened hisogram. We can plot one side of the violinplot and in this case it is called a density plot: ggplot(ChickWeight_sub, aes(y=weight)) + geom_density(fill=&quot;grey90&quot;) These plots are typically rotated 90 degrees: ggplot(ChickWeight_sub, aes(x=weight)) + geom_density(fill=&quot;grey90&quot;) To add the data we can use geom_rug(): ggplot(ChickWeight_sub, aes(x=weight)) + geom_density(fill=&quot;grey90&quot;) + geom_rug() 8.6.3 Histogram To display these data as a histogram instead: ggplot(ChickWeight_sub, aes(x=weight)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. And we can combine them: ggplot(ChickWeight_sub, aes(x=weight)) + geom_histogram() + geom_density() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The density estimate is invisible, since it has a different amplitude. To solve this: # From: https://stackoverflow.com/questions/37404002/geom-density-to-match-geom-histogram-binwitdh ggplot(ChickWeight_sub, aes(x=weight)) + geom_histogram(binwidth = 10, fill=&quot;grey80&quot;) + geom_density(aes(y = 10*..count..), fill=&quot;black&quot;, alpha=0.5) One thing that is not so nice is the margin between the plot and the axis. To remove the margin: # From: https://stackoverflow.com/questions/37404002/geom-density-to-match-geom-histogram-binwitdh ggplot(ChickWeight_sub, aes(x=weight)) + geom_histogram(binwidth = 10, fill=&quot;grey80&quot;) + geom_density(aes(y = 10*..count..), fill=&quot;black&quot;, alpha=0.5) + scale_y_continuous(expand = c(0,NA)) To further improve this, we can set the maximal value of the x-axis: # From: https://stackoverflow.com/questions/37404002/geom-density-to-match-geom-histogram-binwitdh ggplot(ChickWeight_sub, aes(x=weight)) + geom_histogram(binwidth = 10, fill=&quot;grey80&quot;) + geom_density(aes(y = 10*..count..), fill=&quot;black&quot;, alpha=0.5) + scale_y_continuous(expand = c(0,NA), limits = c(0,11)) 8.7 Two distributions 8.7.1 Histogram &amp; Density It is possible to overlay multiple histograms and/or density curves: ChickWeight %&gt;% filter(Diet %in% c(2,3)) %&gt;% filter(Time %in% c(0,2,4,6,16,18,20,21)) %&gt;% ggplot(aes(x=weight, fill=Diet)) + geom_histogram(binwidth = 10) + geom_density(aes(y = 10*..count..), alpha=0.5) + scale_y_continuous(expand = c(0,NA), limits = c(0,21)) By default the histograms are stacked (unlike the density plot), making it difficult to compare them. This can be solved and requires tranparancy because they partially overlap. ChickWeight %&gt;% filter(Diet %in% c(2,3)) %&gt;% filter(Time %in% c(0,2,4,6,16,18,20,21)) %&gt;% ggplot(aes(x=weight, fill=Diet)) + geom_histogram(binwidth = 10, alpha=0.8, position=&quot;identity&quot;) + geom_density(aes(y = 10*..count..), alpha=0.5) + scale_y_continuous(expand = c(0,NA), limits = c(0,11)) 8.7.2 Splitting into two plots However, overlaying histograms is usually not a great idea as this generates a cluttered plot. One way to solve this is by splitting the data with facet_wrap(). We can use labeller to use both the parameter as its value for labeling the plots. In this case the legend can be removed as it is redundant, allowing more space for the data: ChickWeight %&gt;% filter(Diet %in% c(2,3)) %&gt;% filter(Time %in% c(0,2,4,6,16,18,20,21)) %&gt;% ggplot(aes(x=weight, fill=Diet)) + geom_histogram(binwidth = 10, alpha=0.8, position=&quot;identity&quot;) + geom_density(aes(y = 10*..count..), alpha=0.5) + scale_y_continuous(expand = c(0,NA), limits = c(0,11)) + facet_wrap(~Diet, labeller = label_both) + theme(legend.position = &quot;none&quot;) "],["heatmaps-et-al.---base-r.html", "Chapter 9 Heatmaps et al. - base R 9.1 Setup 9.2 Loading data 9.3 Basic heatmaps 9.4 Decorating heatmaps", " Chapter 9 Heatmaps et al. - base R 9.1 Setup In this chapter, we take a look at R for visualizing data matrices. if(!require(RColorBrewer)){ install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(RColorBrewer) } if(!require(gplots)){ install.packages(&quot;gplots&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(gplots) } if(!require(gtools)){ install.packages(&quot;gtools&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(gtools) } ## Loading required package: gtools Heatmaps are a commonly used visualization tool for large data matrices, where you’d have many features (e.g. gene’s expression values, microbial abundances, metabolite levels…) measured over a bunch of samples. 9.2 Loading data In this example, we’ll work with a metabolomics dataset from a study on gastectomy, processed for a meta-analysis. There is also some metadata available. metabo &lt;- read.delim(&quot;../datasets/ERAWIJANTARI_metab.tsv&quot;,row.names=1) #data colnames(metabo) &lt;- sub(&quot;^X&quot;,&quot;&quot;,colnames(metabo)) metabo &lt;- as.matrix(metabo) metabo_log &lt;- log10(metabo) metaD &lt;- read.delim(&quot;../datasets/ERAWIJANTARI_metaD.tsv&quot;) #metadata all(colnames(metabo) == metaD$Sample) #check that samples match in data matrices ## [1] TRUE With 96 samples and 211 metabolites, this is not a huge data set. But it’s awkward to analyse and visualize bit by bit. A heatmap can give a quick overview. 9.3 Basic heatmaps 9.3.1 A simple heatmap Here’s how the default heatmap looks: heatmap(metabo) Every column represents one sample, every row represents a metabolite. Let’s for a moment ignore that there are too many datapoints to plot all the labels - indeed, let’s ignore the labels for now: heatmap(metabo, labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5)) # remove the white space around 9.3.2 Scaling What this simple visualization does not tell you is what the colours mean - we’ll come back to that later - but the darker colours are higher values. You see that there are some high values for all metabolites. When you think about it, this must mean that something was done to our data, because you would never find all metabolites at a similar level. This is true, the default setting for a heatmap is to scale by row. This means that the average value per row has the middle colour, and the further a value is away from the average, the lighter or darker it will be. How light or dark? scaling takes the distribution into account, so all values that are one standard deviation higher than its row’s average have the same colour. You can turn scaling off: heatmap(metabo, scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5)) # remove the white space around Now, you’ve lost most information, except that you can see that there are really very few metabolites with a high value. It’s not useful not to scale for this kind of data, but if all your rows have similar values, it can be better. You can see this, if you use the log-transformed version of the data set, where all values sit somewhere between -1 and 6: You could also scale by column: heatmap(metabo_log, scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5)) # remove the white space around Instant patterns! As an exercise, plot the heatmap for this data set with row scaling (scale = \"row\"). When comparing no scaling and row-scaling, you see that no scaling emphasizes the absolute values, while row-scaling emphasizes differences between samples. It depends on your question which visualization is appropriate. heatmap(metabo_log, scale = &quot;col&quot;, # column scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5)) # remove the white space around Now some of the columns which were lighter before cannot be distinguished anymore. So, you see, scaling is important for the visual impression. Generally, we would recommend that you transform and normalize (and potentially scale/centre) your data set appropriately, before you visualize it. That way, your analyses are performed correctly and on the thing you see. What exactly is “appropriate” depends on your data set. Here, we’re just learning visualization, so we’ll stick with the un-normalized, un-scaled/centred (but log-transformed) data. 9.3.3 Colour schemes A lot of the information in heatmaps comes from the colours. So it’s important to choose good colors. Generally speaking, if the data is not centred/scaled, use light colours for low values and darker colours for high values. If you are plotting a scaled/centred data set, it’s good practice to have a neutral color (black or whiteish) in the middle and stronger colours for the extremes: heatmap(metabo_log, col = hcl.colors(12,&quot;RdYlBu&quot;, rev = TRUE), #diverging palette scale = &quot;row&quot;, # row scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5)) # remove the white space around It would be nice to have a colour bar here. So, let’s use a bit more fancy function - which also centers the colours: heatmap.2(metabo_log, col = hcl.colors(13,&quot;RdYlBu&quot;, rev = TRUE), #diverging palette scale = &quot;row&quot;, # row scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar 13 colour steps were not really enough (R’s base heatmap function uses only 12…), so here we set it to 255, giving a smooth colour scale: heatmap.2(metabo_log, col = hcl.colors(255,&quot;RdYlBu&quot;, rev = TRUE), #diverging palette - 255 colours! scale = &quot;row&quot;, # row scaling labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar This would be the un-scaled image: heatmap.2(metabo_log, col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette! - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar The colour key is a bit buggy, but Fortunately, it’s R, so we can change the function. Here’s the code (not displayed in the .html). 9.4 Decorating heatmaps 9.4.1 Dendrograms The other thing that determines the impression of heatmaps is the order of the features and the samples. By default, R tries to make the picture as clear as possible. This is achieved by re-ordering the features and samples using dendrograms. Let’s take a look at our heatmap without the dendrogram and ordering: heatmap.2a(metabo_log, dendrogram = &quot;none&quot;, #no dendrogram plotted Rowv = F, #no sorting for rows Colv = F, #no sorting for columns col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar It’s hard to believe that these are the same values, right? The default dendrogram is based on Euclidean distances, which are hierarchically clustered using complete linkage. You can supply your own dendrograms, based on your choice of distance: heatmap.2a(metabo_log, dendrogram = &quot;both&quot;, #both dendrograms plotted Rowv = as.dendrogram(hclust(dist(metabo_log,&quot;minkowski&quot;), &quot;ward.D2&quot;)), #custom Colv = as.dendrogram(hclust(dist(t(metabo_log)), &quot;ward.D2&quot;)), #custom dendrogram col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar The choice of distance is up to you and depends on your data and what you consider ‘different.’ Most fields of research have (more or less justified) standards. *Try out some of the options you can find under ?dist and ?hclust to see effects. 9.4.2 Ordering features and samples We’ve already seen the power of sorting. Next to ordering you data based on clustering (you might call this ‘unsupervised’), you can have pre-defined groups (especially for samples). You can also visualize those: heatmap.2a(metabo_log[,order(metaD$Status,metaD$Gender,metaD$BMI)],# custom order using metadata: by study group, gender, and BMI dendrogram = &quot;row&quot;, # row dendrogram plotted Colv = NULL, col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar Some structure is still visible. So, this looks like some of the metabolites behave a bit differently in the samples on the left than on the right. But the most obvious differences between samples we seemed to see before may be due to something else. We can indicate the separation of groups with vertical lines: heatmap.2a(metabo_log[,order(metaD$Status,metaD$Gender,metaD$BMI)],# custom order using metadata: by study group, gender, and BMI dendrogram = &quot;row&quot;, # row dendrogram plotted Colv = NULL, # no sorting (except above) colsep = cumsum(c(t(table(metaD$Status,metaD$Gender)))), #counting the grouping from above! col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling! labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar 9.4.3 Adding attributes We can add some sample information to the heatmap using colours for a similar effect: heatmap.2a(metabo_log, ColSideColors = c(&quot;purple&quot;,&quot;green&quot;)[as.numeric(as.factor(metaD$Status))], dendrogram = &quot;both&quot;, #both dendrograms plotted col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar Our improved heatmap.2a also takes multiple attributes for colour codes. heatmap.2a(metabo_log, ColSideColors = rbind(c(&quot;pink&quot;,&quot;lightblue&quot;)[as.numeric(as.factor(metaD$Gender))], brewer.pal(7,&quot;Set3&quot;)[as.numeric(as.factor(metaD$Gastric.acid.medication))], c(&quot;purple&quot;,&quot;green&quot;)[as.numeric(as.factor(metaD$Status))]), dendrogram = &quot;both&quot;, #both dendrograms plotted col = hcl.colors(255,&quot;YlGnBu&quot;, rev = TRUE), #single colour palette - 255 colours symbreaks = F, #colours are not centred around 0 scale = &quot;none&quot;, # no scaling labRow = &quot;&quot;, # no rownames labCol = &quot;&quot;, # no colnames margins = c(0.5,0.5), # remove the white space around trace = &quot;none&quot;, #don&#39;t plot a trace density.info = &quot;none&quot;) #don&#39;t overlay a histogram in the colour bar There are more options to tweak. Take a look at ?heatmap.2 to see them. "],["venn-euler-and-upset-diagrams.html", "Chapter 10 Venn, Euler, and upSet diagrams 10.1 Setup and data 10.2 Venn diagrams 10.3 Euler diagrams 10.4 UpSet plots", " Chapter 10 Venn, Euler, and upSet diagrams In this chapter, we take a look at R packages and functions to plot sets and their overlaps in R. We will look at 3 visualizations: Venn diagrams, Euler diagrams, and UpSet plots. 10.1 Setup and data Venn diagrams show all logical relationships between multiple sets. There is no dedicated function to plot them in base R. Here, we will use the eulerr package. The demo data comes from the UpSetR package that we will use more later. The demo data is a database of movies with genre tags. In this case, every row contains one movie, every genre is represented by a column. The fields are filled by 0 or 1. 1 indicates that the movie belongs to that genre, 0 means that the movie does not belong to the genre. movies &lt;- read.csv( system.file(&quot;extdata&quot;, &quot;movies.csv&quot;, package = &quot;UpSetR&quot;), header=TRUE, sep=&quot;;&quot; ) head(movies) ## Name ReleaseDate Action Adventure Children ## 1 Toy Story (1995) 1995 0 0 1 ## 2 Jumanji (1995) 1995 0 1 1 ## 3 Grumpier Old Men (1995) 1995 0 0 0 ## 4 Waiting to Exhale (1995) 1995 0 0 0 ## 5 Father of the Bride Part II (1995) 1995 0 0 0 ## 6 Heat (1995) 1995 1 0 0 ## Comedy Crime Documentary Drama Fantasy Noir Horror Musical Mystery Romance ## 1 1 0 0 0 0 0 0 0 0 0 ## 2 0 0 0 0 1 0 0 0 0 0 ## 3 1 0 0 0 0 0 0 0 0 1 ## 4 1 0 0 1 0 0 0 0 0 0 ## 5 1 0 0 0 0 0 0 0 0 0 ## 6 0 1 0 0 0 0 0 0 0 0 ## SciFi Thriller War Western AvgRating Watches ## 1 0 0 0 0 4.15 2077 ## 2 0 0 0 0 3.20 701 ## 3 0 0 0 0 3.02 478 ## 4 0 0 0 0 2.73 170 ## 5 0 0 0 0 3.01 296 ## 6 0 1 0 0 3.88 940 Let’s focus on the 2, 3, and 4 genres with the most movies. We remove movies that don’t belong to those genres (although it’s not strictly speaking necessary). movies2 &lt;- movies[,c(9,6)] #keep only Comedy and Drama rownames(movies2) &lt;- movies[,1] movies2 &lt;- movies2[rowSums(movies2)&gt;0,] #remove movies that are neither Comedy nor Drama movies3 &lt;- movies[,c(9,6,3)] #keep only Comedy, Drama, and Action rownames(movies3) &lt;- movies[,1] movies3 &lt;- movies3[rowSums(movies3)&gt;0,] #remove movies that are neither Comedy nor Drama nor Action movies4 &lt;- movies[,c(9,6,3,17)] #keep only Comedy, Drama, Action, and Thriller rownames(movies4) &lt;- movies[,1] movies4 &lt;- movies4[rowSums(movies4)&gt;0,] #remove movies that are neither Comedy nor Drama nor Action nor Thriller 10.2 Venn diagrams Plotting is very simple from this format and the default plot looks okay. plot(venn(movies2)) You can adjust the plot, e.g. the colours of the lines and fills: plot(venn(movies2),edges=c(&quot;red&quot;,&quot;blue&quot;),fills=c(&quot;red&quot;,&quot;blue&quot;)) Or just the fills: plot(venn(movies2),fills=c(&quot;yellow&quot;,&quot;lightgreen&quot;)) Or the labels: plot(venn(movies2),fills=c(&quot;yellow&quot;,&quot;lightgreen&quot;),edges=NA, labels = c(&quot;dramatic movies&quot;,&quot;comedic movies&quot;)) Exercise: try the same in new chunks with the sets of 3 or 4 genres. Above, we’ve used one kind of input format. The venn function understands some more formats. You can use them depending on the original shape of your data. For two groups, this notation can be handy if you know the intersect sizes already: movies2_combi_manual &lt;- setNames(c(1377, 974, 226), #values from above c(&quot;Drama&quot;, &quot;Comedy&quot;, &quot;Drama&amp;Comedy&quot;)) #names and intersect with &amp; plot(venn(movies2_combi_manual),fills=c(&quot;yellow&quot;,&quot;lightgreen&quot;),edges=NA) Here’s one way to get the numbers automatically: movies2_combi_A &lt;- sum(movies2$Drama) - length(which(rowSums(movies2)==2)) movies2_combi_B &lt;- sum(movies2$Comedy) - length(which(rowSums(movies2)==2)) movies2_combi_AB &lt;- length(which(rowSums(movies2)==2)) movies2_combies &lt;- setNames(c(movies2_combi_A, movies2_combi_B, movies2_combi_AB), c(&quot;Drama&quot;, &quot;Comedy&quot;, &quot;Drama&amp;Comedy&quot;)) plot(venn(movies2_combies),fills=c(&quot;yellow&quot;,&quot;lightgreen&quot;),edges=NA) Or, if your sets are not available as a table, but rather as a named list with a vector per set: movies2_set_A &lt;- rownames(movies2)[which(movies2$Drama&gt;0)] #a vector with all dramas movies2_set_B &lt;- rownames(movies2)[which(movies2$Comedy&gt;0)] #a vector with all comedies movies2_setlist &lt;- list(&quot;Drama&quot; = movies2_set_A, &quot;Comedy&quot; = movies2_set_B) # a list with both vectors plot(venn(movies2_setlist),fills=c(&quot;yellow&quot;,&quot;lightgreen&quot;),edges=NA) # intersect is found automatically 10.3 Euler diagrams Euler diagrams are similar to Venn diagrams, with two exceptions: first, Euler diagrams try to draw every area proportional to the number of elements in the set/intersection they represent; therefore, secondly, Euler diagrams don’t include intersecting areas, if there are no elements that intersect between two sets. To demonstrate this, let’s look at another set of three genres: movies3b &lt;- movies[,c(5,15,17)] #keep only Children, Thriller, and Romance rownames(movies3b) &lt;- movies[,1] movies3b &lt;- movies3b[rowSums(movies3b)&gt;0,] #remove movies that don&#39;t belong to our genres plot(venn(movies3b),fills=c(&quot;orange&quot;,&quot;pink&quot;,&quot;purple&quot;),edges=NA) You see the 0 in the middle, meaning there are (perhaps reassuringly) no children’s movies that are also romantic thrillers. Now with the Euler diagram: plot(euler(movies3b),fills=c(&quot;orange&quot;,&quot;pink&quot;,&quot;purple&quot;),edges=NA, quantities=T) You see, there are three fields with overlaps of all pairs, and the intersection of all sets is non-existent. You also see that the circles and intersections are pretty much to scale, with the children’s circle visibly smaller than the others. Exercise: Do the same thing for the other movies data sets we created above. Which of them can be visualized faithfully? what about the others? 10.4 UpSet plots Euler diagrams are only guaranteed to work for two sets. After that, the circles cannot always be drawn area-proportionally. Venn diagrams can theoretically be plotted for many more sets, but they become really confusing (click for an example of Venn-related humour). Probably, the most elegant solution to visualize the sizes of overlaps between sets is offered by upSet plots. In R, functions are provided by the UpSetR package. Let’s first look at the small data set from above: upset(movies3) The UpSet plot is quite easy to read: at the bottom left, you have a barplot visualizing the sizes of the sets (here, the genres). To its right a black point in each set’s row means that the set belongs to a combination of sets (including the set on its own). Combinations of more than one set are emphasized by vertical lines. The barplot at the top shows the size of the combination. Exercise: try this with our 4-genre set. Upsets power becomes clear, when we take the whole data set (17 genres): upset(movies, nsets = 17, nintersects = 40, mb.ratio = c(0.5, 0.5), order.by = &quot;freq&quot;) To be fair, we did not plot all of the intersects here (nintersects argument above). But we can quickly see which genres and combinations are most common in our database. We can limit the number of genres like so: upset(movies, nsets = 10, nintersects = 40, mb.ratio = c(0.5, 0.5), order.by = &quot;freq&quot;) Exercise: what’s the most common 3-genre combination? You can modify the look of the plot, by e.g. adding colours to the bars. Most of the time, these are not really informative, so we’ll not go into detail here. You can also use the plot to summarize data in the combinations in boxplots. We could show the ratings, for example: upset(movies, nsets = 17, nintersects = 40, mb.ratio = c(0.5, 0.5), order.by = &quot;freq&quot;, boxplot.summary = &quot;AvgRating&quot;) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? Exercise: make an upset plot with the year the movies were released shown in a boxplot. "],["visualizing-networks-with-igraph.html", "Chapter 11 Visualizing networks with igraph 11.1 Setup 11.2 Network representations 11.3 Network visualization", " Chapter 11 Visualizing networks with igraph In this chapter, we take a look at networks. R can handle networks, both for analysis as well as for visualization. There are several packages to help with this job. The methods in this tutorial are based on the igraph package. The igraph project actually interfaces with several programming languages, so you may also find it in other contexts. 11.1 Setup if(!require(igraph)){ install.packages(&quot;igraph&quot;,repos = &quot;http://cran.us.r-project.org&quot;) library(igraph) } ## Loading required package: igraph ## ## Attaching package: &#39;igraph&#39; ## The following object is masked from &#39;package:gtools&#39;: ## ## permute ## The following objects are masked from &#39;package:dplyr&#39;: ## ## as_data_frame, groups, union ## The following objects are masked from &#39;package:purrr&#39;: ## ## compose, simplify ## The following object is masked from &#39;package:tidyr&#39;: ## ## crossing ## The following object is masked from &#39;package:tibble&#39;: ## ## as_data_frame ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union 11.2 Network representations There are multiple ways of reading in or defining a network. The two most common ways to represent a network are edge lists and adjacency matrices. 11.2.1 Network formats: edgelist In the first representation, you have a table with at least two columns. Every line represents an edge. The two columns take the two nodes that are connected in this line. Directionality is straight-forward with this: You can define one column to contain only source nodes (where the arrow starts) and the other column to contain only sink or target nodes (where the arrow ends). Un-directed networks can be (implicitly or explicitly) defined by giving every edge twice, with the source and sink nodes of one line being exchanged in the other line. Directionality and weights can also be defined in additional columns. A common input file format is simple interaction format. Here is the example of a simple network. edgelist_circle1 &lt;- matrix(c(&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;D&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;,&quot;F&quot;,&quot;F&quot;,&quot;A&quot;), byrow = T, ncol=2, dimnames = list(c(1:6),c(&quot;source&quot;,&quot;sink&quot;))) edgelist_circle1 ## source sink ## 1 &quot;A&quot; &quot;B&quot; ## 2 &quot;B&quot; &quot;C&quot; ## 3 &quot;C&quot; &quot;D&quot; ## 4 &quot;D&quot; &quot;E&quot; ## 5 &quot;E&quot; &quot;F&quot; ## 6 &quot;F&quot; &quot;A&quot; testgraph_circle1 &lt;- graph_from_edgelist(edgelist_circle1) plot(testgraph_circle1, layout = layout_in_circle(testgraph_circle1)) 11.2.2 Network formats: adjacency matrix The second representation is a square matrix with one row and one column each for every node. The fields that are spanned by this matrix contain information on whether an edge connects the node belonging to this row and the node belonging to this column. Usually, 0 indicates no connection and 1 indicates a connection (weights can be introduced, too, if necessary). Directionality is dealt with by using the two triangles of the matrix: the matrix is read such that the rows indicate source nodes and the columns sink nodes for the edges. #make an empty matrix with as many rows and columns as there are nodes adjMat_circle2 &lt;- matrix(0, nrow=6, ncol=6, dimnames = list(c(&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;), c(&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;))) #fill matrix by connecting each node to only the next for(i in 1:(nrow(adjMat_circle2)-1)){ adjMat_circle2[i,i+1] &lt;- 1 } #close the circle adjMat_circle2[nrow(adjMat_circle2),1] &lt;- 1 adjMat_circle2 ## J K L M N O ## J 0 1 0 0 0 0 ## K 0 0 1 0 0 0 ## L 0 0 0 1 0 0 ## M 0 0 0 0 1 0 ## N 0 0 0 0 0 1 ## O 1 0 0 0 0 0 testgraph_circle2 &lt;- graph_from_adjacency_matrix(adjMat_circle2) plot(testgraph_circle2, layout = layout_in_circle(testgraph_circle2)) Exercise: In the code below, change the edgelist in a way that breaks the circle and adds a new edge instead. Plot the result. edgelist_new &lt;- matrix(c(&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;D&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;,&quot;F&quot;,&quot;F&quot;,&quot;A&quot;), #adapt this byrow = T, ncol=2, dimnames = list(c(1:6),c(&quot;source&quot;,&quot;sink&quot;))) edgelist_new ## source sink ## 1 &quot;A&quot; &quot;B&quot; ## 2 &quot;B&quot; &quot;C&quot; ## 3 &quot;C&quot; &quot;D&quot; ## 4 &quot;D&quot; &quot;E&quot; ## 5 &quot;E&quot; &quot;F&quot; ## 6 &quot;F&quot; &quot;A&quot; testgraph_new1 &lt;- graph_from_edgelist(edgelist_new) plot(testgraph_new1, layout = layout_in_circle(testgraph_new1)) Exercise: In the code below, change the adjacency matrix in a way that breaks the circle and adds a new edge instead. Plot the result. adjMat_new &lt;- adjMat_circle2 #replace at least two fields by adjusting the following lines (you need to un-comment them by removing the hashkey): # adjMat_new[x1,y1] &lt;- 0 # adjMat_new[x2,y2] &lt;- 1 adjMat_new ## J K L M N O ## J 0 1 0 0 0 0 ## K 0 0 1 0 0 0 ## L 0 0 0 1 0 0 ## M 0 0 0 0 1 0 ## N 0 0 0 0 0 1 ## O 1 0 0 0 0 0 testgraph_new2 &lt;- graph_from_adjacency_matrix(adjMat_new ) plot(testgraph_new2, layout = layout_in_circle(testgraph_new2)) 11.3 Network visualization base R and igraph are not really made for visualizing large graphs/networks. There’s better software outthere for those tasks. But what is nice is that you can integrate your visualization with the functions to analyse graphs and R’s statistical tools and all the visualizations for the results from those functions. So let’s take a look at igraph’s options for plotting graphs. We’ll first create a simple graph from a built-in function. In real life, you’d be using an igraph object that you created from an adjacency matrix or an edge list, depending on your data. g &lt;- graph_from_atlas(501) plot(g) As you can see, this graph’s nodes don’t have names. Let’s give them some. V(g)$name &lt;- c(&quot;Maria&quot;,&quot;Johannes&quot;,&quot;Jan&quot;,&quot;Johanna&quot;,&quot;Cornelis&quot;,&quot;Hendrik&quot;,&quot;Anna&quot;) plot(g) 11.3.1 Layouts Layouts are what determine where the nodes sit on the canvas. By default, igraph guesses a good layout algorithm for your graph’s size. For a small graph, this is usually a Fruchterman-Reingold force-directed layout, which will put more connected nodes closer to each other. It can also be chosen explicitly: plot(g,layout = layout_with_fr(g)) One important point to notice is that the layout does not always look the same. If you run the above chunk a couple of times, you will end up with slightly different positions of your nodes. This can be a problem, if you want to plot the same graph twice, but highlight different aspects. In this case, you can save a layout. frg &lt;- layout_with_fr(g) Now, you can re-use this layout - run the following chunk a couple of times, you will see that nothing changes: plot(g, layout=frg) You’ve already met the circle layout above: plot(g,layout = layout_in_circle(g)) More layouts include stars: plot(g,layout = layout_as_star(g)) … as trees (this one is nice for tree-like structures, e.g. pedigrees): plot(g,layout = layout_as_tree(g)) … other algorithms that try to bring more connected nodes together while avoiding crowding, e.g., … using the Kamada-Kawai layout: plot(g,layout = layout_with_kk(g)) … using the GEM layout: plot(g,layout = layout_with_gem(g)) … or using multi-dimensional scaling of the distances between the nodes in the graph (problematic with equi-distant nodes like we have them here): plot(g,layout = layout_with_mds(g)) … or just plain random: plot(g,layout = layout_randomly(g)) You can even set all the coordinates manually, by giving one coordinate per node in a \\(n\\times2\\) matric (n being the number of nodes). plot(g,layout = matrix(sample(1:7,14,replace=T),nrow=7,ncol=2)) 11.3.2 Node labels Let’s keep our FR-layout from above and manipulate its look. Exercise: play around with the visualization arguments shown below to understand how they work. Let’s start with the labels. You can choose not to plot them: plot(g, layout=frg, vertex.label = NA) #no labels In a very un-R-ish way, the default labels have serifs. You can change to a more usual sans serif font like so: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;) # sans serif labels And change the color: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;) #color … and the size: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.7) # size … also for the individual nodes: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.2*1:7) # size With this, you could also take values from an analysis, e.g. the degree (i.e. number of connections) of the nodes: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.2*degree(g)) # size based on degree The labels don’t need to sit in the node: plot(g, layout=frg, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc 11.3.3 Node shapes and sizes You have a choice of different shapes, e.g. circles, squares, rectangles, spheres. plot(g, layout=frg, vertex.shape=&quot;square&quot;, vertex.size = 40, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, # label color vertex.label.cex = 0.6) # label size As always, they can be set by node: plot(g, layout=frg, vertex.shape=c(&quot;square&quot;,&quot;circle&quot;)[1+as.numeric(grepl(&quot;nn&quot;,V(g)$name))], vertex.size = 40, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, # label color vertex.label.cex = 0.6) # label size Colours of both the node and its frame can be chosen freely, too: plot(g, layout=frg, vertex.shape=c(&quot;square&quot;,&quot;circle&quot;)[1+as.numeric(grepl(&quot;nn&quot;,V(g)$name))], vertex.color = c(&quot;darkgreen&quot;,&quot;orange&quot;)[1+as.numeric(grepl(&quot;^J&quot;,V(g)$name))], vertex.frame.color = c(&quot;black&quot;,&quot;grey&quot;), # vectors are not recycled, any node without a value gets an NA vertex.size = 40, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, # label color vertex.label.cex = 0.6) # label size A special case of nodes are pies: plot(g, layout=frg, vertex.shape= &quot;pie&quot;, vertex.size = 30, vertex.pie = list(c(1,1,0,2), c(2,1,0,1), c(3,1,0,0), c(4,0,1,0), c(2,2,0,3), c(1,1,0,1), c(4,4,0,1), c(5,0,0,1)), vertex.pie.color = list(rainbow(4)), vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, # label color vertex.label.cex = 0.6, # label size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc Which are especially effective with the size vector: pieList &lt;- list(c(1,1,0,2), c(2,1,0,1), c(3,1,0,0), c(4,0,1,0), c(2,2,0,3), c(1,1,0,1), c(4,4,0,1), c(5,0,0,1)) plot(g, layout=frg, vertex.shape= &quot;pie&quot;, vertex.size = sapply(pieList,sum)*6, vertex.pie = pieList, vertex.pie.color = list(rainbow(4)), vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, # label color vertex.label.cex = 0.6, # label size vertex.label.dist = rep(3,7), # label distance to node centre vertex.label.degree = rep(0,7)) # label position 0=right, pi=left, pi/2=below etc ## Warning in label.dist * cos(-label.degree) * (vertex.size + 6 * 8 * log10(2)): ## longer object length is not a multiple of shorter object length ## Warning in layout[, 1] + label.dist * cos(-label.degree) * (vertex.size + : ## longer object length is not a multiple of shorter object length ## Warning in label.dist * sin(-label.degree) * (vertex.size + 6 * 8 * log10(2)): ## longer object length is not a multiple of shorter object length ## Warning in layout[, 2] + label.dist * sin(-label.degree) * (vertex.size + : ## longer object length is not a multiple of shorter object length 11.3.4 Edge appearance Of course, the edges can also be controlled individually. plot(g, layout=frg, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc … including the line type: plot(g, layout=frg, edge.lty = 3, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc … and the thickness: plot(g, layout=frg, edge.width = 3, edge.lty = 2, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc … which can, of course be adapted per edge: plot(g, layout=frg, edge.width = sqrt(edge_betweenness(g)), edge.lty = 2, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc Edges can be curved: plot(g, layout=frg, edge.curved = T, edge.width = sqrt(edge_betweenness(g)), edge.lty = 1, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc … and more or less curved: plot(g, layout=frg, edge.curved = 0.1, edge.width = sqrt(edge_betweenness(g)), edge.lty = 1, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc plot(g, layout=frg, edge.curved = -2, edge.width = sqrt(edge_betweenness(g)), edge.lty = 1, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc Of course, edges may have labels: plot(g, layout=frg, edge.label = E(g), edge.label.family = &quot;sans&quot;, edge.label.cex = 0.6, edge.label.color = &quot;magenta&quot;, edge.label.font = 3, edge.curved = 0.1, edge.width = sqrt(edge_betweenness(g)), edge.lty = 1, edge.color = &quot;black&quot;, vertex.label.family = &quot;sans&quot;, # sans serif labels vertex.label.color = &quot;black&quot;, #color vertex.label.cex = 0.6, # size vertex.label.dist = 3, # label distance to node centre vertex.label.degree = 0) # label position 0=right, pi=left, pi/2=below etc You can also add a title, box and other things. See ?igraph.plotting for further tips. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
